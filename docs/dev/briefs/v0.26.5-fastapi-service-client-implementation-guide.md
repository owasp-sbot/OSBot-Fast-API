# FastAPI Service Client Implementation Guide: Contract-Driven AST Generation
*Version 1.1 - September 29, 2025*

## Executive Summary

This document defines a contract-driven approach for automatically generating Python clients for FastAPI services using the OSBot-Utils AST infrastructure. The approach leverages Type_Safe schemas as contracts and the existing AST abstraction layer to create maintainable, type-safe clients that perfectly mirror the service structure.

The key innovation is using OSBot-Utils' structured AST classes (like `Ast_Module`, `Ast_Function_Def`, `Ast_Class_Def`) instead of raw Python AST manipulation. This provides cleaner code generation, better maintainability, and seamless integration with the Type_Safe ecosystem. The generated clients support three transparent execution modes (remote, in-memory, local server) through a unified request handling layer.

## Core Architecture Decisions

### 1. Contract as Source of Truth

The **Service Contract** is a Type_Safe schema that captures the complete interface between client and server. This contract serves as the single source of truth for generating client code, ensuring perfect alignment between service and client.

**Why contracts matter**: Traditional approaches require manual synchronization between service and client code. When a service endpoint changes, developers must remember to update all client code. Contracts eliminate this manual process by defining the interface once and generating both validation and client code from that single definition.

**Implementation details**: The contract is extracted directly from the FastAPI service's Routes classes using OSBot-Utils AST infrastructure, ensuring it always reflects the actual implementation rather than documentation that might be outdated.

### 2. OSBot-Utils AST-Based Code Generation

Instead of working with raw Python AST nodes (which are difficult to manipulate and reason about), we use OSBot-Utils' AST abstraction layer. This provides several critical advantages:

**Structured node representation**: Each AST node type has a dedicated class (`Ast_Function_Def`, `Ast_Class_Def`, etc.) with an `info()` method that returns structured, Type_Safe-compatible data. This makes it easy to inspect and modify AST structures programmatically.

**Clean traversal patterns**: The `Ast_Visit` class implements the visitor pattern for AST traversal, with built-in support for capturing specific node types. This simplifies complex operations like finding all route methods in a service.

**Module composition**: The `Ast_Merge` class allows building complex Python files incrementally by merging AST modules. This is perfect for generating client code where we need to combine imports, base classes, and multiple method definitions.

### 3. Three Transparent Execution Modes

All clients support three execution modes that are **completely transparent to the client code**. The client doesn't know or care which mode is active - it just calls methods and gets results. This transparency is achieved through a dedicated request handling layer (`Cache__Client__Requests` pattern).

**Mode implementation**: The execution mode is determined at client initialization and handled entirely within the request layer:

```python
class Cache__Client__Requests(Type_Safe):
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None          # FastAPI app for in-memory
    _server      : Optional[Fast_API_Server] = None  # Local server instance
    _session     : Optional[requests.Session] = None # HTTP session for remote
    
    def execute(self, method: str, path: str, body: Any = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on current mode"""
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            # Use FastAPI TestClient
            return self._execute_in_memory(method, path, body)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            # Use local Fast_API_Server instance
            return self._execute_local_server(method, path, body)
        else:
            # Use requests library for remote calls
            return self._execute_remote(method, path, body)
```

**Why transparency matters**: Tests can run against in-memory mode for speed, integration tests can use local server mode for HTTP validation, and production uses remote mode - all without changing a single line of client code.

## Contract Schema Definition

### Core Contract Types

The contract system uses Type_Safe schemas to define the complete service interface. These schemas capture not just the data structures, but also the routing patterns, HTTP methods, and error handling requirements.

```python
from enum import Enum
from typing import Type, Optional, List, Dict, Any
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version import Safe_Str__Version
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

class Enum__Http__Method(str, Enum):
    GET    = "GET"
    POST   = "POST"
    PUT    = "PUT"
    DELETE = "DELETE"
    PATCH  = "PATCH"

class Enum__Param__Location(str, Enum):
    PATH   = "path"
    QUERY  = "query"
    HEADER = "header"
    BODY   = "body"

class Enum__Client__Mode(str, Enum):
    REMOTE       = "remote"        # HTTP calls to deployed service
    IN_MEMORY    = "in_memory"     # FastAPI TestClient (same process)
    LOCAL_SERVER = "local_server"  # Fast_API_Server (local HTTP server)

class Schema__Endpoint__Param(Type_Safe):
    name         : Safe_Str__Id                      # Parameter name
    location     : Enum__Param__Location             # Where parameter appears
    param_type   : Type[Type_Safe]                   # Actual Type_Safe class reference
    required     : bool = True                       # Is parameter required?
    default      : Optional[Any] = None              # Default value if any
    description  : Optional[Safe_Str__Text] = None   # Parameter documentation

class Schema__Endpoint__Contract(Type_Safe):
    # Endpoint identity
    operation_id : Safe_Str__Id                      # Unique operation identifier
    method       : Enum__Http__Method                # HTTP method
    path_pattern : Safe_Str__File__Path              # URL pattern with {params}
    
    # Route class mapping
    route_class  : Safe_Str__Id                      # e.g., "Routes__File__Store"
    route_method : Safe_Str__Id                      # Original method name in route
    route_module : Optional[Safe_Str__Id] = None     # Module path (e.g., "file", "admin")
    
    # Parameters
    path_params  : List[Schema__Endpoint__Param] = []
    query_params : List[Schema__Endpoint__Param] = []
    header_params: List[Schema__Endpoint__Param] = []
    
    # Request/Response schemas  
    request_schema : Optional[Type[Type_Safe]] = None      # Request body Type_Safe class
    response_schema: Optional[Type[Type_Safe]] = None      # Response Type_Safe class
    
    # Error handling
    error_schemas: Dict[int, Type[Type_Safe]] = {}   # Status code -> Error schema

class Schema__Routes__Module(Type_Safe):
    """Represents a module of routes (e.g., 'file', 'admin', 'data')"""
    module_name  : Safe_Str__Id                      # e.g., "file", "admin"
    route_classes: List[Safe_Str__Id]                # e.g., ["Routes__File__Store", "Routes__File__Retrieve"]
    endpoints    : List[Schema__Endpoint__Contract]  # All endpoints in this module

class Schema__Service__Contract(Type_Safe):
    service_name : Safe_Str__Id                      # Service identifier
    version      : Safe_Str__Version                 # Contract version
    base_path    : Safe_Str__File__Path = ""         # Base URL path
    modules      : List[Schema__Routes__Module]      # Organized route modules
    endpoints    : List[Schema__Endpoint__Contract]  # All service endpoints (flat list)
    
    # Metadata
    generated_at    : Timestamp_Now                  # When contract was generated
    service_version : Safe_Str__Version              # Version of service
    client_version  : Safe_Str__Version              # Minimum client version required
```

### Contract Storage Structure

The contract and generated code follow a structure that mirrors the service organization:

```
mgraph_ai_service_cache_client/
├── contract/
│   ├── contract.json                  # Current contract (serialized)
│   ├── contract_history/              # Previous versions for comparison
│   │   └── contract_v0.5.64.json
│   ├── contract_schema.py             # Type_Safe schema definitions
│   └── contract_extractor.py          # Extract contract from service
├── client/
│   ├── Cache__Client.py               # Main client class
│   ├── Cache__Client__Config.py       # Configuration
│   ├── Cache__Client__Requests.py     # Request handling (3 modes)
│   ├── admin/
│   │   └── Cache__Client__Admin__Storage.py
│   ├── data/
│   │   ├── Cache__Client__Data__Delete.py
│   │   ├── Cache__Client__Data__Retrieve.py
│   │   └── Cache__Client__Data__Store.py
│   ├── file/
│   │   ├── Cache__Client__File__Delete.py
│   │   ├── Cache__Client__File__Exists.py
│   │   ├── Cache__Client__File__Retrieve.py
│   │   └── Cache__Client__File__Store.py
│   └── zip/
│       └── Cache__Client__Zip.py
```

## OSBot-Utils AST-Based Code Generation

### AST Generator Architecture Using OSBot-Utils

The generator leverages OSBot-Utils' AST infrastructure to create clean, maintainable client code. Instead of manipulating raw AST nodes, we work with structured classes that provide intuitive interfaces.

```python
from pathlib import Path
from typing import Dict, List
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
from osbot_utils.helpers.ast.nodes.Ast_Class_Def import Ast_Class_Def
from osbot_utils.helpers.ast.nodes.Ast_Function_Def import Ast_Function_Def

class AST__Client__Generator(Type_Safe):
    contract     : Schema__Service__Contract
    output_dir   : Path
    
    def generate_client(self) -> Dict[str, str]:
        """Generate complete client from contract using OSBot AST"""
        
        generated_files = {}
        
        # Generate main client class
        main_client = self._generate_main_client()
        generated_files['client/Cache__Client.py'] = main_client
        
        # Generate module-specific client classes
        for module in self.contract.modules:
            module_files = self._generate_module_clients(module)
            generated_files.update(module_files)
        
        # Generate request handler
        request_handler = self._generate_request_handler()
        generated_files['client/Cache__Client__Requests.py'] = request_handler
        
        return generated_files
    
    def _generate_main_client(self) -> str:
        """Generate the main Cache__Client class"""
        
        # Start with a template
        template = '''
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.decorators.methods.cache_on_self import cache_on_self
from mgraph_ai_service_cache_client.client.Cache__Client__Config import Cache__Client__Config
from mgraph_ai_service_cache_client.client.Cache__Client__Requests import Cache__Client__Requests

class Cache__Client(Type_Safe):
    config   : Cache__Client__Config
    _requests: Cache__Client__Requests = None
'''
        
        # Parse template into AST
        ast_module = Ast_Module(template)
        
        # Find the class definition
        with Ast_Visit(ast_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
        
        # Add module accessor methods
        for module in self.contract.modules:
            method_ast = self._create_module_accessor(module.module_name)
            class_node.node.body.append(method_ast.node)
        
        # Add request handler accessor
        requests_method = self._create_requests_accessor()
        class_node.node.body.append(requests_method.node)
        
        return ast_module.source_code()
    
    def _generate_module_clients(self, module: Schema__Routes__Module) -> Dict[str, str]:
        """Generate client classes for a specific module (e.g., file, admin)"""
        
        files = {}
        
        for route_class in module.route_classes:
            # Convert Routes__File__Store to Cache__Client__File__Store
            client_class_name = route_class.replace('Routes__', 'Cache__Client__')
            
            # Get endpoints for this route class
            endpoints = [e for e in module.endpoints if e.route_class == route_class]
            
            # Generate the client class
            class_code = self._generate_route_client_class(client_class_name, endpoints)
            
            # Determine file path
            if module.module_name:
                file_path = f'client/{module.module_name}/{client_class_name}.py'
            else:
                file_path = f'client/{client_class_name}.py'
            
            files[file_path] = class_code
        
        return files
    
    def _generate_route_client_class(self, class_name: str, endpoints: List[Schema__Endpoint__Contract]) -> str:
        """Generate a client class for a specific Routes__* class"""
        
        # Create AST merger for building the module
        merger = Ast_Merge()
        
        # Add imports
        imports_code = self._generate_imports_for_endpoints(endpoints)
        merger.merge_module(Ast_Module(imports_code))
        
        # Create class with Type_Safe base
        class_template = f'''
class {class_name}(Type_Safe):
    _cache_client: Any  # Reference to parent Cache__Client
    
    @property
    def requests(self):
        return self._cache_client.requests()
'''
        class_module = Ast_Module(class_template)
        
        # Add method for each endpoint
        with Ast_Visit(class_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
            
            for endpoint in endpoints:
                method_node = self._generate_endpoint_method(endpoint)
                class_node.node.body.append(method_node.node)
        
        merger.merge_module(class_module)
        return merger.source_code()
    
    def _generate_endpoint_method(self, endpoint: Schema__Endpoint__Contract) -> Ast_Function_Def:
        """Generate a method for a specific endpoint using OSBot AST"""
        
        # Build method template based on endpoint
        method_name = endpoint.route_method  # Use the same name as in Routes__* class
        
        # Build parameter list
        params_str = self._build_params_string(endpoint)
        
        # Build return type annotation
        return_type = self._get_return_type_string(endpoint)
        
        # Create method template
        template = f'''
def {method_name}(self{params_str}) -> {return_type}:
    """Auto-generated from {endpoint.operation_id}"""
    path = self._build_path("{endpoint.path_pattern}", locals())
    
    result = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    if result.status_code != 200:
        self._handle_error(result, {endpoint.error_schemas})
    
    if result.json:
        return {return_type}.from_json(result.json)
    return result.content
'''
        
        # Parse and return as Ast_Function_Def
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
    
    def _create_module_accessor(self, module_name: str) -> Ast_Function_Def:
        """Create a @cache_on_self method to access a module's client"""
        
        client_class = f"Cache__Client__{module_name.title()}"
        
        template = f'''
@cache_on_self
def {module_name}(self) -> {client_class}:
    """Access {module_name} operations"""
    from mgraph_ai_service_cache_client.client.{module_name}.{client_class} import {client_class}
    return {client_class}(_cache_client=self)
'''
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

### Method Generation with OSBot AST

The method generation process uses OSBot's AST classes to build clean, properly formatted Python code:

```python
def _generate_method_with_osbot_ast(self, endpoint: Schema__Endpoint__Contract):
    """Generate a client method using OSBot AST infrastructure"""
    
    # Create base method structure
    method_template = '''
def placeholder_method(self):
    pass
'''
    
    # Parse template into AST
    ast_module = Ast_Module(method_template)
    
    # Use Ast_Visit to find and modify the function
    with Ast_Visit(ast_module) as visitor:
        visitor.capture_functions()
        visitor.visit()
        
        func_node = visitor.captured_nodes()['Ast_Function_Def'][0]
        
        # Modify function properties using OSBot AST methods
        func_info = func_node.info()
        
        # Update name
        func_node.node.name = endpoint.route_method
        
        # Update parameters
        self._update_function_params_ast(func_node, endpoint)
        
        # Update body
        self._update_function_body_ast(func_node, endpoint)
        
        # Update return annotation
        self._update_return_annotation_ast(func_node, endpoint)
    
    return ast_module.source_code()

def _update_function_body_ast(self, func_node: Ast_Function_Def, endpoint: Schema__Endpoint__Contract):
    """Update function body using OSBot AST node manipulation"""
    
    # Build new body statements
    body_code = f'''
# Build path from parameters
path = self._build_path("{endpoint.path_pattern}", {{"id": id}})

# Execute request through unified handler
result = self.requests.execute(
    method="{endpoint.method}",
    path=path
)

# Handle response
if result.status_code == 200:
    return {endpoint.response_schema.__name__}.from_json(result.json)
else:
    self._handle_error(result)
'''
    
    # Parse body code and replace function body
    body_module = Ast_Module(body_code)
    func_node.node.body = body_module.node.body
```

## Client Implementation Architecture

### Transparent Request Handling

The key to transparent execution modes is the `Cache__Client__Requests` class, which handles all HTTP communication regardless of the underlying execution mode. This pattern ensures client code never needs to know about the execution context.

```python
from typing import Any, Optional, Dict
from enum import Enum
import requests
from fastapi.testclient import TestClient
from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Cache__Client__Requests(Type_Safe):
    """Unified request handler supporting three transparent execution modes"""
    
    config       : Cache__Client__Config
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None              # FastAPI app
    _server      : Optional[Fast_API_Server] = None  # Local server
    _test_client : Optional[TestClient] = None       # In-memory client
    _session     : Optional[requests.Session] = None # HTTP session
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._setup_mode()
    
    def _setup_mode(self):
        """Initialize the appropriate execution backend"""
        
        if self._app:
            # In-memory mode with FastAPI TestClient
            self.mode = Enum__Client__Mode.IN_MEMORY
            self._test_client = TestClient(self._app)
            
        elif self._server:
            # Local server mode
            self.mode = Enum__Client__Mode.LOCAL_SERVER
            if not isinstance(self._server, Fast_API_Server):
                self._server = Fast_API_Server(app=self._server)
            
        else:
            # Remote mode with requests
            self.mode = Enum__Client__Mode.REMOTE
            self._session = requests.Session()
            self._configure_session()
    
    def execute(self, method: str, path: str, body: Any = None, 
                headers: Optional[Dict] = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on mode"""
        
        # Add auth headers
        headers = {**self.auth_headers(), **(headers or {})}
        
        # Execute based on mode
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            response = self._execute_in_memory(method, path, body, headers)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            response = self._execute_local_server(method, path, body, headers)
        else:
            response = self._execute_remote(method, path, body, headers)
        
        # Convert to unified result format
        return self._build_result(response, path)
    
    def _execute_in_memory(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using FastAPI TestClient (same process, no HTTP)"""
        
        method_func = getattr(self._test_client, method.lower())
        if body:
            return method_func(path, json=body, headers=headers)
        else:
            return method_func(path, headers=headers)
    
    def _execute_local_server(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using local Fast_API_Server (real HTTP, localhost)"""
        
        url = f"{self._server.base_url()}{path}"
        method_func = getattr(requests, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
    
    def _execute_remote(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using requests to remote service"""
        
        url = f"{self.config.target_server}{path}"
        method_func = getattr(self._session, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
```

### Module Organization Following Service Structure

The client structure exactly mirrors the service's route organization. Each `Routes__*` class becomes a `Cache__Client__*` class with the same method names:

```python
class Cache__Client:
    """Main client with module accessors matching service structure"""
    
    @cache_on_self
    def admin(self) -> Cache__Client__Admin:
        """Access admin operations (Routes__Admin__* methods)"""
        return Cache__Client__Admin(_cache_client=self)
    
    @cache_on_self
    def data(self) -> Cache__Client__Data:
        """Access data operations (Routes__Data__* methods)"""
        return Cache__Client__Data(_cache_client=self)
    
    @cache_on_self
    def file(self) -> Cache__Client__File:
        """Access file operations (Routes__File__* methods)"""
        return Cache__Client__File(_cache_client=self)
    
    @cache_on_self
    def zip(self) -> Cache__Client__Zip:
        """Access zip operations (Routes__Zip methods)"""
        return Cache__Client__Zip(_cache_client=self)

# Module client example
class Cache__Client__File:
    """Groups all file-related route clients"""
    
    @cache_on_self
    def store(self) -> Cache__Client__File__Store:
        """Routes__File__Store methods"""
        return Cache__Client__File__Store(_cache_client=self._cache_client)
    
    @cache_on_self
    def retrieve(self) -> Cache__Client__File__Retrieve:
        """Routes__File__Retrieve methods"""
        return Cache__Client__File__Retrieve(_cache_client=self._cache_client)
    
    @cache_on_self
    def delete(self) -> Cache__Client__File__Delete:
        """Routes__File__Delete methods"""
        return Cache__Client__File__Delete(_cache_client=self._cache_client)
    
    @cache_on_self
    def exists(self) -> Cache__Client__File__Exists:
        """Routes__File__Exists methods"""
        return Cache__Client__File__Exists(_cache_client=self._cache_client)

# Individual route client with exact method names
class Cache__Client__File__Store:
    """Client for Routes__File__Store - uses same method names"""
    
    def store_json(self, data: dict, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_json()"""
        # Implementation auto-generated from contract
    
    def store_bytes(self, data: bytes, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_bytes()"""
        # Implementation auto-generated from contract
```

## Contract Extraction Using OSBot AST

### Extracting Contract from Service with OSBot-Utils

The contract extraction process leverages OSBot's AST infrastructure to analyze the service's route classes and build a complete contract:

```python
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
from osbot_utils.utils.Files import folder_files

class Contract__Extractor(Type_Safe):
    service_path : Path  # Path to service fast_api/routes folder
    
    def extract_contract(self) -> Schema__Service__Contract:
        """Extract complete contract from service routes using OSBot AST"""
        
        contract = Schema__Service__Contract(
            service_name="cache-service",
            version="v0.1.0"
        )
        
        # Find all route files
        routes_folder = self.service_path / "fast_api" / "routes"
        modules = self._discover_route_modules(routes_folder)
        
        for module_path, module_name in modules.items():
            module_contract = self._extract_module_contract(module_path, module_name)
            contract.modules.append(module_contract)
            contract.endpoints.extend(module_contract.endpoints)
        
        return contract
    
    def _extract_module_contract(self, module_path: Path, module_name: str) -> Schema__Routes__Module:
        """Extract contract from a specific module folder"""
        
        module_contract = Schema__Routes__Module(
            module_name=module_name,
            route_classes=[],
            endpoints=[]
        )
        
        # Find all Routes__* files in module
        route_files = folder_files(module_path, "Routes__*.py")
        
        for route_file in route_files:
            # Extract route class name from filename
            route_class = route_file.stem  # e.g., "Routes__File__Store"
            module_contract.route_classes.append(route_class)
            
            # Parse the file using OSBot AST
            ast_module = Ast_Module(route_file)
            
            # Extract endpoints from this route class
            endpoints = self._extract_endpoints_from_route(ast_module, route_class, module_name)
            module_contract.endpoints.extend(endpoints)
        
        return module_contract
    
    def _extract_endpoints_from_route(self, ast_module: Ast_Module, 
                                     route_class: str, 
                                     module_name: str) -> List[Schema__Endpoint__Contract]:
        """Extract all endpoints from a Routes__* class using OSBot AST"""
        
        endpoints = []
        
        with Ast_Visit(ast_module) as visitor:
            # Capture the class definition
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            
            for class_node in visitor.captured_nodes()['Ast_Class_Def']:
                if class_node.name() == route_class:
                    # Find setup_routes method to determine HTTP methods
                    setup_routes_map = self._extract_setup_routes_mapping(class_node)
                    
                    # Extract each route method
                    for func_node in self._get_route_methods(class_node):
                        endpoint = self._build_endpoint_contract(
                            func_node, 
                            route_class, 
                            module_name,
                            setup_routes_map
                        )
                        endpoints.append(endpoint)
        
        return endpoints
    
    def _extract_setup_routes_mapping(self, class_node: Ast_Class_Def) -> Dict[str, str]:
        """Extract the HTTP method mapping from setup_routes()"""
        
        mapping = {}
        
        # Find setup_routes method
        for node in class_node.body():
            if isinstance(node, Ast_Function_Def) and node.name() == "setup_routes":
                # Analyze add_route_* calls
                with Ast_Visit(node) as visitor:
                    visitor.capture_calls()
                    visitor.visit()
                    
                    for call_node in visitor.captured_nodes()['Ast_Call']:
                        call_name = call_node.name()
                        if call_name and call_name.startswith('add_route_'):
                            http_method = call_name.replace('add_route_', '').upper()
                            # Get the method being registered
                            if call_node.args():
                                method_ref = call_node.args()[0]
                                if hasattr(method_ref, 'node') and hasattr(method_ref.node, 'attr'):
                                    method_name = method_ref.node.attr
                                    mapping[method_name] = http_method
        
        return mapping
    
    def _build_endpoint_contract(self, func_node: Ast_Function_Def,
                                 route_class: str,
                                 module_name: str,
                                 http_methods: Dict[str, str]) -> Schema__Endpoint__Contract:
        """Build endpoint contract from function AST node"""
        
        func_info = func_node.info()['Ast_Function_Def']
        method_name = func_info['name']
        
        # Derive path pattern from method name (OSBot-Fast-API convention)
        path_pattern = self._derive_path_from_method_name(method_name, module_name)
        
        # Extract parameters
        params = self._extract_parameters_from_ast(func_info['args'])
        
        # Determine HTTP method
        http_method = http_methods.get(method_name, "GET")
        
        return Schema__Endpoint__Contract(
            operation_id=f"{route_class}.{method_name}",
            method=http_method,
            path_pattern=path_pattern,
            route_class=route_class,
            route_method=method_name,
            route_module=module_name,
            path_params=params['path'],
            query_params=params['query']
        )
    
    def _extract_parameters_from_ast(self, args_node: Ast_Arguments) -> Dict[str, List]:
        """Extract parameter information from function arguments AST"""
        
        params = {'path': [], 'query': []}
        
        for arg in args_node.args():
            if arg.name() != 'self':
                # Analyze the argument to determine if it's path or query
                param = Schema__Endpoint__Param(
                    name=arg.name(),
                    param_type=self._resolve_type_annotation(arg.annotation()),
                    location='path' if '__' in arg.name() else 'query'
                )
                
                if param.location == 'path':
                    params['path'].append(param)
                else:
                    params['query'].append(param)
        
        return params
```

### Contract Comparison with OSBot AST

The contract comparison process uses OSBot's structured data approach to detect changes:

```python
class Contract__Comparator(Type_Safe):
    
    def compare_with_ast_analysis(self, old: Schema__Service__Contract, 
                                  new: Schema__Service__Contract) -> Schema__Contract__Diff:
        """Compare contracts using OSBot AST's structured info() format"""
        
        diff = Schema__Contract__Diff()
        
        # Convert contracts to structured format using OSBot patterns
        old_info = self._contract_to_info(old)
        new_info = self._contract_to_info(new)
        
        # Use OSBot's json_data pattern for deep comparison
        changes = self._deep_compare_info(old_info, new_info)
        
        # Analyze changes for breaking modifications
        for change in changes:
            if self._is_breaking_change(change):
                diff.breaking_changes.append(change)
            else:
                diff.non_breaking_changes.append(change)
        
        return diff
    
    def _contract_to_info(self, contract: Schema__Service__Contract) -> Dict:
        """Convert contract to OSBot AST info() style format"""
        
        info = {
            'service_name': contract.service_name,
            'modules': {}
        }
        
        for module in contract.modules:
            module_info = {
                'route_classes': module.route_classes,
                'endpoints': {}
            }
            
            for endpoint in module.endpoints:
                endpoint_info = {
                    'method': endpoint.method,
                    'path': endpoint.path_pattern,
                    'params': {
                        'path': [p.name for p in endpoint.path_params],
                        'query': [p.name for p in endpoint.query_params]
                    }
                }
                module_info['endpoints'][endpoint.operation_id] = endpoint_info
            
            info['modules'][module.module_name] = module_info
        
        return info
```

## Error Handling Strategy

### Custom Exception Hierarchy with Type_Safe

The error handling system uses Type_Safe schemas for error data, ensuring type safety even in error conditions:

```python
# Error schemas
class Schema__Cache__Error(Type_Safe):
    """Base error schema"""
    error_code : Safe_Str__Id
    message    : Safe_Str__Text
    timestamp  : Timestamp_Now
    request_id : Safe_Str__Id = None

class Schema__Cache__Error__Not_Found(Schema__Cache__Error):
    """404 error with resource details"""
    resource_type : Safe_Str__Id
    resource_id   : Safe_Str__Id

class Schema__Cache__Error__Invalid_Input(Schema__Cache__Error):
    """400 error with validation details"""
    field_errors : Dict[Safe_Str__Id, Safe_Str__Text]

# Exception classes
class Cache__Client__Error(Exception):
    """Base exception for cache client errors"""
    error_schema: Schema__Cache__Error
    
    def __init__(self, error_schema: Schema__Cache__Error):
        self.error_schema = error_schema
        super().__init__(str(error_schema.message))

class Cache__Client__Error__Not_Found(Cache__Client__Error):
    """404 - Resource not found"""
    error_schema: Schema__Cache__Error__Not_Found

class Cache__Client__Error__Invalid_Input(Cache__Client__Error):
    """400 - Invalid input"""
    error_schema: Schema__Cache__Error__Invalid_Input
```

### Error Handling in Generated Code

The AST generator creates comprehensive error handling based on the contract:

```python
def _generate_error_handling_ast(self, endpoint: Schema__Endpoint__Contract) -> str:
    """Generate error handling code using OSBot AST"""
    
    error_handlers = []
    
    for status_code, error_schema in endpoint.error_schemas.items():
        handler = f'''
if response.status_code == {status_code}:
    error_data = {error_schema.__name__}.from_json(response.json())
    raise Cache__Client__Error__{error_schema.__name__.replace("Schema__Cache__Error__", "")}(error_data)
'''
        error_handlers.append(handler)
    
    # Add generic handler
    error_handlers.append('''
# Generic error for unexpected status codes
response.raise_for_status()
''')
    
    return '\n'.join(error_handlers)
```

## Testing Strategy

### Test Structure Following Type_Safe and OSBot Patterns

Tests leverage the three execution modes and OSBot's testing patterns:

```python
from unittest import TestCase
from osbot_utils.testing.__ import __, __SKIP__

class test_Cache__Client(TestCase):
    
    @classmethod
    def setUpClass(cls):
        """Expensive setup once for all tests (OSBot pattern)"""
        # Create service once
        cls.fast_api = Cache__Service__Fast_API()
        cls.fast_api.setup()
        cls.app = cls.fast_api.app()
    
    def test_transparent_modes(self):
        """Test that all three modes work transparently"""
        
        test_data = {"key": "value"}
        
        # Test remote mode
        if os.getenv("CACHE_SERVICE_URL"):
            client_remote = Cache__Client(
                config=Cache__Client__Config(
                    target_server=os.getenv("CACHE_SERVICE_URL")
                )
            )
            result_remote = client_remote.file().store().store_json(test_data)
            assert isinstance(result_remote, Schema__Store__Response)
        
        # Test in-memory mode (fastest for unit tests)
        client_memory = Cache__Client(_app=self.app)
        result_memory = client_memory.file().store().store_json(test_data)
        assert isinstance(result_memory, Schema__Store__Response)
        
        # Test local server mode (real HTTP)
        with Fast_API_Server(app=self.app) as server:
            client_local = Cache__Client(_server=server)
            result_local = client_local.file().store().store_json(test_data)
            assert isinstance(result_local, Schema__Store__Response)
        
        # All three modes return the same type!
    
    def test_module_structure_mirrors_service(self):
        """Test that client structure matches service structure"""
        
        with Cache__Client(app=self.app) as client:
            # Main modules
            assert hasattr(client, 'admin')
            assert hasattr(client, 'data')
            assert hasattr(client, 'file')
            assert hasattr(client, 'zip')
            
            # File sub-operations
            file_client = client.file()
            assert hasattr(file_client, 'store')
            assert hasattr(file_client, 'retrieve')
            assert hasattr(file_client, 'delete')
            assert hasattr(file_client, 'exists')
            
            # Methods match Routes__* methods exactly
            store_client = file_client.store()
            assert hasattr(store_client, 'store_json')
            assert hasattr(store_client, 'store_bytes')
```

## CI/CD Integration

### Contract Validation Pipeline

The CI pipeline ensures contracts stay synchronized:

```yaml
# .github/workflows/contract-validation.yml
name: Contract Validation

on:
  pull_request:
    paths:
      - 'mgraph_ai_service_cache/fast_api/routes/**'

jobs:
  validate_contract:
    runs-on: ubuntu-latest
    steps:
      - name: Extract Current Contract using OSBot AST
        run: |
          python -m mgraph_ai_service_cache_client.contract.extract \
            --service-path ../mgraph_ai_service_cache \
            > contract_new.json
      
      - name: Compare Contracts using OSBot AST
        run: |
          python -m mgraph_ai_service_cache_client.contract.compare \
            contract/contract.json contract_new.json \
            --use-osbot-ast
      
      - name: Generate Client if Changed
        if: steps.compare.outputs.changed == 'true'
        run: |
          python -m mgraph_ai_service_cache_client.contract.generate \
            --contract contract_new.json \
            --output client/ \
            --generator osbot-ast
      
      - name: Run Contract Tests with All Modes
        run: |
          # Test in-memory mode
          pytest tests/test_contract_compliance.py -m in_memory
          
          # Test local server mode
          pytest tests/test_contract_compliance.py -m local_server
          
          # Test remote mode if configured
          if [ -n "$CACHE_SERVICE_URL" ]; then
            pytest tests/test_contract_compliance.py -m remote
          fi
```

### Automated Client Updates Using OSBot AST

```python
class Client__Updater(Type_Safe):
    """Automated client updater using OSBot AST infrastructure"""
    
    def update_if_needed(self) -> bool:
        """Check for contract changes and update client using OSBot AST"""
        
        # Extract current contract using OSBot AST
        extractor = Contract__Extractor(service_path=self.service_path)
        current_contract = extractor.extract_contract()
        
        # Load stored contract
        stored_contract = self.load_stored_contract()
        
        # Compare using OSBot AST comparison
        comparator = Contract__Comparator()
        diff = comparator.compare_with_ast_analysis(stored_contract, current_contract)
        
        if diff.has_changes():
            # Generate new client code using OSBot AST
            generator = AST__Client__Generator(contract=current_contract)
            generated_files = generator.generate_client()
            
            # Write generated files preserving OSBot structure
            for filepath, content in generated_files.items():
                self.write_file_preserving_structure(filepath, content)
            
            # Update stored contract
            self.save_contract(current_contract)
            
            # Run tests to validate
            self.run_validation_tests()
            
            return True
        
        return False
```

## Performance Optimizations

### Connection Pooling for Remote Mode

The remote mode uses optimized session management:

```python
class Cache__Client__Requests__Remote__Optimized(Cache__Client__Requests):
    """Optimized remote request handling"""
    
    def _configure_session(self):
        """Configure session with connection pooling and retry logic"""
        
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        
        # Configure retry strategy
        retry = Retry(
            total=3,
            backoff_factor=0.3,
            status_forcelist=[500, 502, 503, 504]
        )
        
        # Configure connection pooling
        adapter = HTTPAdapter(
            max_retries=retry,
            pool_connections=10,
            pool_maxsize=20,
            pool_block=False
        )
        
        self._session.mount('http://', adapter)
        self._session.mount('https://', adapter)
        
        # Set default timeout
        self._session.timeout = 30

### Caching for Immutable Operations

Leverage OSBot's @cache_on_self for immutable operations:

```python
class Cache__Client__File__Retrieve:
    
    @cache_on_self
    def retrieve_by_hash(self, cache_hash: Safe_Str__Hash) -> Schema__Cache__Item:
        """Cache results for immutable hash lookups"""
        # Hash-based retrieval is immutable - same hash always returns same data
        return self._retrieve_by_hash_impl(cache_hash)
```

## Implementation Checklist

- [ ] **OSBot AST Integration** - Extend OSBot AST classes for client generation
- [ ] **Contract Schema** - Define Type_Safe contract schemas with route structure
- [ ] **Contract Extraction** - Use Ast_Visit to extract from Routes__* classes  
- [ ] **AST Generator** - Build generator using Ast_Module, Ast_Merge, Ast_Function_Def
- [ ] **Transparent Modes** - Implement Cache__Client__Requests with three modes
- [ ] **Module Structure** - Generate client structure mirroring service routes
- [ ] **Method Naming** - Use exact same method names as Routes__* classes
- [ ] **Error Handling** - Create typed exception hierarchy with Type_Safe schemas
- [ ] **Generated Code** - Generate initial client from contract using OSBot AST
- [ ] **Tests** - Write tests for all three transparent modes
- [ ] **CI Pipeline** - Set up contract validation with OSBot AST tools
- [ ] **Documentation** - Generate client docs from OSBot AST info() data
- [ ] **Performance** - Add connection pooling and @cache_on_self
- [ ] **Versioning** - Implement semantic versioning based on AST diff analysis

## Summary

This implementation guide provides a complete blueprint for building contract-driven FastAPI clients using OSBot-Utils AST infrastructure:

1. **OSBot AST classes** provide clean abstractions over raw Python AST
2. **Type_Safe contracts** serve as the single source of truth
3. **Three transparent execution modes** via unified request handling
4. **Exact service structure mirroring** with Routes__* → Cache__Client__* mapping
5. **Same method names** preserved from service to client
6. **Automated contract extraction** using Ast_Visit and Ast_Module
7. **Clean code generation** with Ast_Merge and structured node manipulation
8. **Type-safe error handling** with proper exception hierarchy
9. **CI/CD integration** for contract compliance and automated updates
10. **Performance optimizations** leveraging OSBot patterns

The approach eliminates manual client maintenance while preserving full type safety, IDE support, and the exact service structure throughout the entire request/response lifecycle.