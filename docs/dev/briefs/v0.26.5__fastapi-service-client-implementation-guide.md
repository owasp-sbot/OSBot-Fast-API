# FastAPI Service Client Implementation Guide: Contract-Driven AST Generation
*Version 1.1 - September 29, 2025*

## Executive Summary

This document defines a contract-driven approach for automatically generating Python clients for FastAPI services using a hybrid of FastAPI's runtime route information and OSBot-Utils AST infrastructure. The approach leverages Type_Safe schemas as contracts and combines FastAPI's actual route registry (for accurate paths and methods) with OSBot AST analysis (for detecting internal logic like exception handling).

A critical insight is that **Type_Safe validation on the client eliminates entire categories of server errors**. When both client and server use Type_Safe, validation errors (400/422) become impossible - invalid data is caught at assignment time on the client, before any network request. This dramatically simplifies the generated client code, eliminates unnecessary error handling, and provides faster failure with better error messages.

The generated clients support three transparent execution modes (remote, in-memory, local server) through a unified request handling layer, with the execution mode completely invisible to the client code.

## Core Architecture Decisions

### 1. Contract as Source of Truth

The **Service Contract** is a Type_Safe schema that captures the complete interface between client and server. This contract serves as the single source of truth for generating client code, ensuring perfect alignment between service and client.

**Why contracts matter**: Traditional approaches require manual synchronization between service and client code. When a service endpoint changes, developers must remember to update all client code. Contracts eliminate this manual process by defining the interface once and generating both validation and client code from that single definition.

**Implementation details**: The contract is extracted directly from the FastAPI service's Routes classes using OSBot-Utils AST infrastructure, ensuring it always reflects the actual implementation rather than documentation that might be outdated.

### 2. OSBot-Utils AST-Based Code Generation

Instead of working with raw Python AST nodes (which are difficult to manipulate and reason about), we use OSBot-Utils' AST abstraction layer. This provides several critical advantages:

**Structured node representation**: Each AST node type has a dedicated class (`Ast_Function_Def`, `Ast_Class_Def`, etc.) with an `info()` method that returns structured, Type_Safe-compatible data. This makes it easy to inspect and modify AST structures programmatically.

**Clean traversal patterns**: The `Ast_Visit` class implements the visitor pattern for AST traversal, with built-in support for capturing specific node types. This simplifies complex operations like finding all route methods in a service.

**Module composition**: The `Ast_Merge` class allows building complex Python files incrementally by merging AST modules. This is perfect for generating client code where we need to combine imports, base classes, and multiple method definitions.

### 3. Three Transparent Execution Modes

All clients support three execution modes that are **completely transparent to the client code**. The client doesn't know or care which mode is active - it just calls methods and gets results. This transparency is achieved through a dedicated request handling layer (`Cache__Client__Requests` pattern).

**Mode implementation**: The execution mode is determined at client initialization and handled entirely within the request layer:

```python
class Cache__Client__Requests(Type_Safe):
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None          # FastAPI app for in-memory
    _server      : Optional[Fast_API_Server] = None  # Local server instance
    _session     : Optional[requests.Session] = None # HTTP session for remote
    
    def execute(self, method: str, path: str, body: Any = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on current mode"""
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            # Use FastAPI TestClient
            return self._execute_in_memory(method, path, body)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            # Use local Fast_API_Server instance
            return self._execute_local_server(method, path, body)
        else:
            # Use requests library for remote calls
            return self._execute_remote(method, path, body)
```

**Why transparency matters**: Tests can run against in-memory mode for speed, integration tests can use local server mode for HTTP validation, and production uses remote mode - all without changing a single line of client code.

## Contract Schema Definition

### Core Contract Types

The contract system uses Type_Safe schemas to define the complete service interface. These schemas capture not just the data structures, but also the routing patterns, HTTP methods, and error handling requirements.

```python
from enum import Enum
from typing import Type, Optional, List, Dict, Any
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version import Safe_Str__Version
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

class Enum__Http__Method(str, Enum):
    GET    = "GET"
    POST   = "POST"
    PUT    = "PUT"
    DELETE = "DELETE"
    PATCH  = "PATCH"

class Enum__Param__Location(str, Enum):
    PATH   = "path"
    QUERY  = "query"
    HEADER = "header"
    BODY   = "body"

class Enum__Client__Mode(str, Enum):
    REMOTE       = "remote"        # HTTP calls to deployed service
    IN_MEMORY    = "in_memory"     # FastAPI TestClient (same process)
    LOCAL_SERVER = "local_server"  # Fast_API_Server (local HTTP server)

class Schema__Endpoint__Param(Type_Safe):
    name         : Safe_Str__Id                      # Parameter name
    location     : Enum__Param__Location             # Where parameter appears
    param_type   : Type[Type_Safe]                   # Actual Type_Safe class reference
    required     : bool = True                       # Is parameter required?
    default      : Optional[Any] = None              # Default value if any
    description  : Optional[Safe_Str__Text] = None   # Parameter documentation

class Schema__Endpoint__Contract(Type_Safe):
    # Endpoint identity
    operation_id : Safe_Str__Id                      # Unique operation identifier
    method       : Enum__Http__Method                # HTTP method
    path_pattern : Safe_Str__File__Path              # URL pattern with {params}
    
    # Route class mapping
    route_class  : Safe_Str__Id                      # e.g., "Routes__File__Store"
    route_method : Safe_Str__Id                      # Original method name in route
    route_module : Optional[Safe_Str__Id] = None     # Module path (e.g., "file", "admin")
    
    # Parameters
    path_params  : List[Schema__Endpoint__Param] = []
    query_params : List[Schema__Endpoint__Param] = []
    header_params: List[Schema__Endpoint__Param] = []
    
    # Request/Response schemas  
    request_schema : Optional[Type[Type_Safe]] = None      # Request body Type_Safe class
    response_schema: Optional[Type[Type_Safe]] = None      # Response Type_Safe class
    
    # Error handling
    error_schemas: Dict[int, Type[Type_Safe]] = {}   # Status code -> Error schema

class Schema__Routes__Module(Type_Safe):
    """Represents a module of routes (e.g., 'file', 'admin', 'data')"""
    module_name  : Safe_Str__Id                      # e.g., "file", "admin"
    route_classes: List[Safe_Str__Id]                # e.g., ["Routes__File__Store", "Routes__File__Retrieve"]
    endpoints    : List[Schema__Endpoint__Contract]  # All endpoints in this module

class Schema__Service__Contract(Type_Safe):
    service_name : Safe_Str__Id                      # Service identifier
    version      : Safe_Str__Version                 # Contract version
    base_path    : Safe_Str__File__Path = ""         # Base URL path
    modules      : List[Schema__Routes__Module]      # Organized route modules
    endpoints    : List[Schema__Endpoint__Contract]  # All service endpoints (flat list)
    
    # Metadata
    generated_at    : Timestamp_Now                  # When contract was generated
    service_version : Safe_Str__Version              # Version of service
    client_version  : Safe_Str__Version              # Minimum client version required
```

### Contract Storage Structure

The contract and generated code follow a structure that mirrors the service organization:

```
mgraph_ai_service_cache_client/
├── contract/
│   ├── contract.json                  # Current contract (serialized)
│   ├── contract_history/              # Previous versions for comparison
│   │   └── contract_v0.5.64.json
│   ├── contract_schema.py             # Type_Safe schema definitions
│   └── contract_extractor.py          # Extract contract from service
├── client/
│   ├── Cache__Client.py               # Main client class
│   ├── Cache__Client__Config.py       # Configuration
│   ├── Cache__Client__Requests.py     # Request handling (3 modes)
│   ├── admin/
│   │   └── Cache__Client__Admin__Storage.py
│   ├── data/
│   │   ├── Cache__Client__Data__Delete.py
│   │   ├── Cache__Client__Data__Retrieve.py
│   │   └── Cache__Client__Data__Store.py
│   ├── file/
│   │   ├── Cache__Client__File__Delete.py
│   │   ├── Cache__Client__File__Exists.py
│   │   ├── Cache__Client__File__Retrieve.py
│   │   └── Cache__Client__File__Store.py
│   └── zip/
│       └── Cache__Client__Zip.py
```

## OSBot-Utils AST-Based Code Generation

### AST Generator Architecture Using OSBot-Utils

The generator leverages OSBot-Utils' AST infrastructure to create clean, maintainable client code. Instead of manipulating raw AST nodes, we work with structured classes that provide intuitive interfaces.

```python
from pathlib import Path
from typing import Dict, List
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
from osbot_utils.helpers.ast.nodes.Ast_Class_Def import Ast_Class_Def
from osbot_utils.helpers.ast.nodes.Ast_Function_Def import Ast_Function_Def

class AST__Client__Generator(Type_Safe):
    contract     : Schema__Service__Contract
    output_dir   : Path
    
    def generate_client(self) -> Dict[str, str]:
        """Generate complete client from contract using OSBot AST"""
        
        generated_files = {}
        
        # Generate main client class
        main_client = self._generate_main_client()
        generated_files['client/Cache__Client.py'] = main_client
        
        # Generate module-specific client classes
        for module in self.contract.modules:
            module_files = self._generate_module_clients(module)
            generated_files.update(module_files)
        
        # Generate request handler
        request_handler = self._generate_request_handler()
        generated_files['client/Cache__Client__Requests.py'] = request_handler
        
        return generated_files
    
    def _generate_main_client(self) -> str:
        """Generate the main Cache__Client class"""
        
        # Start with a template
        template = '''
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.decorators.methods.cache_on_self import cache_on_self
from mgraph_ai_service_cache_client.client.Cache__Client__Config import Cache__Client__Config
from mgraph_ai_service_cache_client.client.Cache__Client__Requests import Cache__Client__Requests

class Cache__Client(Type_Safe):
    config   : Cache__Client__Config
    _requests: Cache__Client__Requests = None
'''
        
        # Parse template into AST
        ast_module = Ast_Module(template)
        
        # Find the class definition
        with Ast_Visit(ast_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
        
        # Add module accessor methods
        for module in self.contract.modules:
            method_ast = self._create_module_accessor(module.module_name)
            class_node.node.body.append(method_ast.node)
        
        # Add request handler accessor
        requests_method = self._create_requests_accessor()
        class_node.node.body.append(requests_method.node)
        
        return ast_module.source_code()
    
    def _generate_module_clients(self, module: Schema__Routes__Module) -> Dict[str, str]:
        """Generate client classes for a specific module (e.g., file, admin)"""
        
        files = {}
        
        for route_class in module.route_classes:
            # Convert Routes__File__Store to Cache__Client__File__Store
            client_class_name = route_class.replace('Routes__', 'Cache__Client__')
            
            # Get endpoints for this route class
            endpoints = [e for e in module.endpoints if e.route_class == route_class]
            
            # Generate the client class
            class_code = self._generate_route_client_class(client_class_name, endpoints)
            
            # Determine file path
            if module.module_name:
                file_path = f'client/{module.module_name}/{client_class_name}.py'
            else:
                file_path = f'client/{client_class_name}.py'
            
            files[file_path] = class_code
        
        return files
    
    def _generate_route_client_class(self, class_name: str, endpoints: List[Schema__Endpoint__Contract]) -> str:
        """Generate a client class for a specific Routes__* class"""
        
        # Create AST merger for building the module
        merger = Ast_Merge()
        
        # Add imports
        imports_code = self._generate_imports_for_endpoints(endpoints)
        merger.merge_module(Ast_Module(imports_code))
        
        # Create class with Type_Safe base
        class_template = f'''
class {class_name}(Type_Safe):
    _cache_client: Any  # Reference to parent Cache__Client
    
    @property
    def requests(self):
        return self._cache_client.requests()
'''
        class_module = Ast_Module(class_template)
        
        # Add method for each endpoint
        with Ast_Visit(class_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
            
            for endpoint in endpoints:
                method_node = self._generate_endpoint_method(endpoint)
                class_node.node.body.append(method_node.node)
        
        merger.merge_module(class_module)
        return merger.source_code()
    
    def _generate_endpoint_method(self, endpoint: Schema__Endpoint__Contract) -> Ast_Function_Def:
        """Generate a method for a specific endpoint using OSBot AST"""
        
        # Build method template based on endpoint
        method_name = endpoint.route_method  # Use the same name as in Routes__* class
        
        # Build parameter list
        params_str = self._build_params_string(endpoint)
        
        # Build return type annotation
        return_type = self._get_return_type_string(endpoint)
        
        # Create method template
        template = f'''
def {method_name}(self{params_str}) -> {return_type}:
    """Auto-generated from {endpoint.operation_id}"""
    path = self._build_path("{endpoint.path_pattern}", locals())
    
    result = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    if result.status_code != 200:
        self._handle_error(result, {endpoint.error_schemas})
    
    if result.json:
        return {return_type}.from_json(result.json)
    return result.content
'''
        
        # Parse and return as Ast_Function_Def
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
    
    def _create_module_accessor(self, module_name: str) -> Ast_Function_Def:
        """Create a @cache_on_self method to access a module's client"""
        
        client_class = f"Cache__Client__{module_name.title()}"
        
        template = f'''
@cache_on_self
def {module_name}(self) -> {client_class}:
    """Access {module_name} operations"""
    from mgraph_ai_service_cache_client.client.{module_name}.{client_class} import {client_class}
    return {client_class}(_cache_client=self)
'''
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

### Method Generation with OSBot AST

The method generation process uses OSBot's AST classes to build clean, properly formatted Python code:

```python
def _generate_method_with_osbot_ast(self, endpoint: Schema__Endpoint__Contract):
    """Generate a client method using OSBot AST infrastructure"""
    
    # Create base method structure
    method_template = '''
def placeholder_method(self):
    pass
'''
    
    # Parse template into AST
    ast_module = Ast_Module(method_template)
    
    # Use Ast_Visit to find and modify the function
    with Ast_Visit(ast_module) as visitor:
        visitor.capture_functions()
        visitor.visit()
        
        func_node = visitor.captured_nodes()['Ast_Function_Def'][0]
        
        # Modify function properties using OSBot AST methods
        func_info = func_node.info()
        
        # Update name
        func_node.node.name = endpoint.route_method
        
        # Update parameters
        self._update_function_params_ast(func_node, endpoint)
        
        # Update body
        self._update_function_body_ast(func_node, endpoint)
        
        # Update return annotation
        self._update_return_annotation_ast(func_node, endpoint)
    
    return ast_module.source_code()

def _update_function_body_ast(self, func_node: Ast_Function_Def, endpoint: Schema__Endpoint__Contract):
    """Update function body using OSBot AST node manipulation"""
    
    # Build new body statements
    body_code = f'''
# Build path from parameters
path = self._build_path("{endpoint.path_pattern}", {{"id": id}})

# Execute request through unified handler
result = self.requests.execute(
    method="{endpoint.method}",
    path=path
)

# Handle response
if result.status_code == 200:
    return {endpoint.response_schema.__name__}.from_json(result.json)
else:
    self._handle_error(result)
'''
    
    # Parse body code and replace function body
    body_module = Ast_Module(body_code)
    func_node.node.body = body_module.node.body
```

## Client Implementation Architecture

### Transparent Request Handling

The key to transparent execution modes is the `Cache__Client__Requests` class, which handles all HTTP communication regardless of the underlying execution mode. This pattern ensures client code never needs to know about the execution context.

```python
from typing import Any, Optional, Dict
from enum import Enum
import requests
from fastapi.testclient import TestClient
from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Cache__Client__Requests(Type_Safe):
    """Unified request handler supporting three transparent execution modes"""
    
    config       : Cache__Client__Config
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None              # FastAPI app
    _server      : Optional[Fast_API_Server] = None  # Local server
    _test_client : Optional[TestClient] = None       # In-memory client
    _session     : Optional[requests.Session] = None # HTTP session
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._setup_mode()
    
    def _setup_mode(self):
        """Initialize the appropriate execution backend"""
        
        if self._app:
            # In-memory mode with FastAPI TestClient
            self.mode = Enum__Client__Mode.IN_MEMORY
            self._test_client = TestClient(self._app)
            
        elif self._server:
            # Local server mode
            self.mode = Enum__Client__Mode.LOCAL_SERVER
            if not isinstance(self._server, Fast_API_Server):
                self._server = Fast_API_Server(app=self._server)
            
        else:
            # Remote mode with requests
            self.mode = Enum__Client__Mode.REMOTE
            self._session = requests.Session()
            self._configure_session()
    
    def execute(self, method: str, path: str, body: Any = None, 
                headers: Optional[Dict] = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on mode"""
        
        # Add auth headers
        headers = {**self.auth_headers(), **(headers or {})}
        
        # Execute based on mode
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            response = self._execute_in_memory(method, path, body, headers)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            response = self._execute_local_server(method, path, body, headers)
        else:
            response = self._execute_remote(method, path, body, headers)
        
        # Convert to unified result format
        return self._build_result(response, path)
    
    def _execute_in_memory(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using FastAPI TestClient (same process, no HTTP)"""
        
        method_func = getattr(self._test_client, method.lower())
        if body:
            return method_func(path, json=body, headers=headers)
        else:
            return method_func(path, headers=headers)
    
    def _execute_local_server(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using local Fast_API_Server (real HTTP, localhost)"""
        
        url = f"{self._server.base_url()}{path}"
        method_func = getattr(requests, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
    
    def _execute_remote(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using requests to remote service"""
        
        url = f"{self.config.target_server}{path}"
        method_func = getattr(self._session, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
```

### Module Organization Following Service Structure

The client structure exactly mirrors the service's route organization. Each `Routes__*` class becomes a `Cache__Client__*` class with the same method names:

```python
class Cache__Client:
    """Main client with module accessors matching service structure"""
    
    @cache_on_self
    def admin(self) -> Cache__Client__Admin:
        """Access admin operations (Routes__Admin__* methods)"""
        return Cache__Client__Admin(_cache_client=self)
    
    @cache_on_self
    def data(self) -> Cache__Client__Data:
        """Access data operations (Routes__Data__* methods)"""
        return Cache__Client__Data(_cache_client=self)
    
    @cache_on_self
    def file(self) -> Cache__Client__File:
        """Access file operations (Routes__File__* methods)"""
        return Cache__Client__File(_cache_client=self)
    
    @cache_on_self
    def zip(self) -> Cache__Client__Zip:
        """Access zip operations (Routes__Zip methods)"""
        return Cache__Client__Zip(_cache_client=self)

# Module client example
class Cache__Client__File:
    """Groups all file-related route clients"""
    
    @cache_on_self
    def store(self) -> Cache__Client__File__Store:
        """Routes__File__Store methods"""
        return Cache__Client__File__Store(_cache_client=self._cache_client)
    
    @cache_on_self
    def retrieve(self) -> Cache__Client__File__Retrieve:
        """Routes__File__Retrieve methods"""
        return Cache__Client__File__Retrieve(_cache_client=self._cache_client)
    
    @cache_on_self
    def delete(self) -> Cache__Client__File__Delete:
        """Routes__File__Delete methods"""
        return Cache__Client__File__Delete(_cache_client=self._cache_client)
    
    @cache_on_self
    def exists(self) -> Cache__Client__File__Exists:
        """Routes__File__Exists methods"""
        return Cache__Client__File__Exists(_cache_client=self._cache_client)

# Individual route client with exact method names
class Cache__Client__File__Store:
    """Client for Routes__File__Store - uses same method names"""
    
    def store_json(self, data: dict, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_json()"""
        # Implementation auto-generated from contract
    
    def store_bytes(self, data: bytes, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_bytes()"""
        # Implementation auto-generated from contract
```

## Contract Extraction Using FastAPI Routes + OSBot AST

### Hybrid Extraction: FastAPI Runtime + AST Analysis

The contract extraction combines FastAPI's runtime route information (which knows the actual paths, HTTP methods, and parameters) with OSBot AST analysis (which can detect exception handling, return types, and internal logic). This hybrid approach gives us the best of both worlds:

```python
from fastapi import FastAPI
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

class Contract__Extractor(Type_Safe):
    
    def extract_contract(self, app: FastAPI) -> Schema__Service__Contract:
        """Extract contract from FastAPI app routes + AST analysis"""
        
        contract = Schema__Service__Contract(
            service_name=app.title,
            version=app.version
        )
        
        # Use FastAPI's actual route registry
        routes_by_module = self._organize_routes_by_module(app.routes)
        
        for module_name, routes in routes_by_module.items():
            module_contract = Schema__Routes__Module(
                module_name=module_name,
                route_classes=[],
                endpoints=[]
            )
            
            for route in routes:
                if not hasattr(route, 'endpoint'):
                    continue
                
                # Get actual runtime information from FastAPI
                endpoint_contract = self._extract_from_fastapi_route(route)
                
                # Enhance with AST analysis for internals
                self._enhance_with_ast_analysis(endpoint_contract, route.endpoint)
                
                module_contract.endpoints.append(endpoint_contract)
            
            contract.modules.append(module_contract)
            contract.endpoints.extend(module_contract.endpoints)
        
        return contract
    
        """Extract endpoint contract from FastAPI route object"""
        
        # Get actual path and method from FastAPI
        endpoint = Schema__Endpoint__Contract(
            path_pattern=route.path,                          # Real path like /{namespace}/{strategy}/store/json
            method=list(route.methods)[0] if route.methods else "GET",
            operation_id=route.endpoint.__name__,
            route_class=route.endpoint.__qualname__.split('.')[0] if '.' in route.endpoint.__qualname__ else None
        )
        
        # Extract path parameters from FastAPI route
        if hasattr(route, 'param_names'):
            for param_name in route.param_names:
                endpoint.path_params.append(Schema__Endpoint__Param(
                    name=param_name,
                    location='path',
                    param_type=self._get_param_type_from_signature(route.endpoint, param_name)
                ))
        
        # Extract query parameters from function signature
        import inspect
        sig = inspect.signature(route.endpoint)
        for param_name, param in sig.parameters.items():
            if param_name not in ['self', 'request'] and param_name not in route.param_names:
                endpoint.query_params.append(Schema__Endpoint__Param(
                    name=param_name,
                    location='query',
                    param_type=param.annotation if param.annotation != inspect.Parameter.empty else str,
                    required=param.default == inspect.Parameter.empty,
                    default=param.default if param.default != inspect.Parameter.empty else None
                ))
        
        return endpoint
    
    def _enhance_with_ast_analysis(self, endpoint: Schema__Endpoint__Contract, func):
        """Use AST to find things FastAPI doesn't know about"""
        
        # Parse the function with OSBot AST
        try:
            ast_module = Ast_Module(func)
            
            # Find actual exceptions raised (not validation errors)
            actual_errors = self._extract_actual_error_codes(ast_module)
            endpoint.expected_error_codes = actual_errors
            
            # Find return type if not obvious
            if not endpoint.response_schema:
                response_type = self._extract_return_type(ast_module)
                endpoint.response_schema = response_type
                
        except Exception:
            # If AST parsing fails, continue with FastAPI info only
            pass
    
    def _extract_actual_error_codes(self, func_ast: Ast_Module) -> List[int]:
        """Find which HTTPExceptions are actually raised (excluding validation)"""
        
        status_codes = []
        
        with Ast_Visit(func_ast) as visitor:
            visitor.capture('Ast_Raise')
            visitor.visit()
            
            for raise_node in visitor.captured_nodes()['Ast_Raise']:
                # Look for HTTPException with specific status codes
                if self._is_http_exception(raise_node):
                    status_code = self._extract_status_code(raise_node)
                    # Only include non-validation errors
                    if status_code not in [400, 422]:
                        status_codes.append(status_code)
        
        # Return unique status codes that matter
        return list(set(status_codes))
    
    def _organize_routes_by_module(self, routes) -> Dict[str, List]:
        """Organize FastAPI routes by module based on path structure"""
        
        routes_by_module = {}
        
        for route in routes:
            if not hasattr(route, 'path'):
                continue
                
            # Determine module from route class name
            if hasattr(route, 'endpoint') and hasattr(route.endpoint, '__qualname__'):
                class_name = route.endpoint.__qualname__.split('.')[0]
                
                # Extract module from class name (e.g., Routes__File__Store -> file)
                if class_name.startswith('Routes__'):
                    parts = class_name.replace('Routes__', '').split('__')
                    if len(parts) > 1:
                        module_name = parts[0].lower()  # e.g., 'file', 'admin', 'data'
                    else:
                        module_name = 'root'
                else:
                    module_name = 'root'
                
                if module_name not in routes_by_module:
                    routes_by_module[module_name] = []
                routes_by_module[module_name].append(route)
        
        return routes_by_module
```

### Contract Comparison with OSBot AST

The contract comparison process uses OSBot's structured data approach to detect changes:

```python
class Contract__Comparator(Type_Safe):
    
    def compare_with_ast_analysis(self, old: Schema__Service__Contract, 
                                  new: Schema__Service__Contract) -> Schema__Contract__Diff:
        """Compare contracts using OSBot AST's structured info() format"""
        
        diff = Schema__Contract__Diff()
        
        # Convert contracts to structured format using OSBot patterns
        old_info = self._contract_to_info(old)
        new_info = self._contract_to_info(new)
        
        # Use OSBot's json_data pattern for deep comparison
        changes = self._deep_compare_info(old_info, new_info)
        
        # Analyze changes for breaking modifications
        for change in changes:
            if self._is_breaking_change(change):
                diff.breaking_changes.append(change)
            else:
                diff.non_breaking_changes.append(change)
        
        return diff
    
    def _contract_to_info(self, contract: Schema__Service__Contract) -> Dict:
        """Convert contract to OSBot AST info() style format"""
        
        info = {
            'service_name': contract.service_name,
            'modules': {}
        }
        
        for module in contract.modules:
            module_info = {
                'route_classes': module.route_classes,
                'endpoints': {}
            }
            
            for endpoint in module.endpoints:
                endpoint_info = {
                    'method': endpoint.method,
                    'path': endpoint.path_pattern,
                    'params': {
                        'path': [p.name for p in endpoint.path_params],
                        'query': [p.name for p in endpoint.query_params]
                    }
                }
                module_info['endpoints'][endpoint.operation_id] = endpoint_info
            
            info['modules'][module.module_name] = module_info
        
        return info
```

## Error Handling Strategy

### Type_Safe Client-Side Validation Eliminates Server Validation Errors

A critical insight: with Type_Safe on both client and server, validation errors (400/422) **cannot happen** during normal operation. Type_Safe validates all data at assignment time on the client, before any network request is made:

```python
# These all fail CLIENT-SIDE, before any network request:

# Invalid GUID - fails immediately
cache_id = Random_Guid("not-a-guid")  # ValueError raised here!
client.file().retrieve(cache_id)      # Never reached, no network call

# Negative number for unsigned int - fails immediately  
age = Safe_UInt__Age(-5)              # ValueError: negative not allowed
client.user().update_age(age)         # Never reached, no network call

# Path traversal attempt - blocked by Safe_Str__Namespace
namespace = Safe_Str__Namespace("../../etc/passwd")  # ValueError raised here!
client.file().store(data, namespace)                 # Never reached, no network call

# Invalid enum value - fails immediately
strategy = Enum__Cache__Strategy("invalid")  # ValueError: not a valid strategy
client.store(data, strategy=strategy)        # Never reached, no network call
```

**This means our generated client code can be dramatically simplified:**

```python
def store_json(self, data        : dict                     ,
                     namespace   : Safe_Str__Namespace      ,
                     strategy    : Enum__Cache__Strategy    
               ) -> Schema__Store__Response:
    """
    No input validation needed - Type_Safe already validated everything!
    No 400/422 handling needed - impossible with valid Type_Safe objects!
    """
    
    path = f"/{namespace}/{strategy}/store/json"
    result = self.requests.execute("POST", path, data)
    
    # Only handle ACTUAL errors that can occur with valid data:
    if result.status_code == 404:
        # Resource genuinely doesn't exist
        raise Cache__Client__Error__Not_Found(f"Namespace {namespace} doesn't exist")
    
    elif result.status_code == 401:
        # Authentication issue
        raise Cache__Client__Error__Unauthorized("Invalid or missing API key")
    
    elif result.status_code == 409:
        # Business logic conflict (not validation)
        raise Cache__Client__Error__Conflict("Resource already exists")
    
    elif result.status_code >= 500:
        # Server error
        raise Cache__Client__Error__Server("Server error occurred")
    
    # Success - we know the response will be valid
    return Schema__Store__Response.from_json(result.json)
```

### Actual Errors vs Validation Errors

With Type_Safe validation on the client, we only need to handle **actual runtime errors**:

| Error Type | Status Code | When It Happens | Example |
|------------|-------------|-----------------|---------|
| **Validation** | 400/422 | **NEVER** - Type_Safe prevents this | Invalid GUID, negative age |
| **Not Found** | 404 | Resource doesn't exist | Namespace was deleted |
| **Unauthorized** | 401 | Auth failure | Invalid API key |
| **Forbidden** | 403 | Permission denied | User lacks access |
| **Conflict** | 409 | Business logic conflict | Duplicate key |
| **Gone** | 410 | Resource expired | Cache TTL expired |
| **Server Error** | 500+ | Server issues | Database down |
| **Network** | - | Connection issues | Timeout, DNS failure |

### Simplified Exception Hierarchy

Since we don't need validation error handling, our exception hierarchy is simpler:

```python
class Cache__Client__Error(Exception):
    """Base exception for cache client errors"""
    error_schema: Schema__Cache__Error
    
    def __init__(self, error_schema: Schema__Cache__Error):
        self.error_schema = error_schema
        super().__init__(str(error_schema.message))

# Only non-validation errors
class Cache__Client__Error__Not_Found(Cache__Client__Error):
    """404 - Resource doesn't exist"""
    pass

class Cache__Client__Error__Unauthorized(Cache__Client__Error):
    """401 - Authentication failed"""
    pass

class Cache__Client__Error__Forbidden(Cache__Client__Error):
    """403 - Permission denied"""
    pass

class Cache__Client__Error__Conflict(Cache__Client__Error):
    """409 - Business logic conflict"""
    pass

class Cache__Client__Error__Gone(Cache__Client__Error):
    """410 - Resource expired"""
    pass

class Cache__Client__Error__Server(Cache__Client__Error):
    """500+ - Server error"""
    pass

class Cache__Client__Error__Network(Cache__Client__Error):
    """Network/connection error"""
    pass
```

### Benefits of Type_Safe Client-Side Validation

This approach provides several critical benefits:

1. **Faster Failure**: Errors are caught immediately on the client, no network round-trip
2. **Better Error Messages**: Type_Safe knows exactly what's wrong with the data
3. **Zero Invalid Traffic**: No network bandwidth wasted on invalid requests
4. **Simpler Generated Code**: No need for complex validation error handling
5. **Smaller Client Library**: Less code to generate, ship, and maintain
6. **Guaranteed Server Protection**: Server never receives invalid data

### Error Handling in Generated Code

The AST generator creates minimal error handling since validation is already done:

```python
def _generate_error_handling_ast(self, endpoint: Schema__Endpoint__Contract) -> str:
    """Generate error handling for actual runtime errors only"""
    
    # Only handle errors that can occur with VALID data
    error_handlers = []
    
    # Get actual error codes from AST analysis (excluding 400/422)
    for status_code in endpoint.expected_error_codes:
        if status_code == 404:
            handler = '''
if response.status_code == 404:
    raise Cache__Client__Error__Not_Found(f"Resource not found: {path}")
'''
        elif status_code == 401:
            handler = '''
if response.status_code == 401:
    raise Cache__Client__Error__Unauthorized("Authentication failed")
'''
        elif status_code == 409:
            handler = '''
if response.status_code == 409:
    raise Cache__Client__Error__Conflict("Resource conflict")
'''
        else:
            continue  # Skip validation errors
        
        error_handlers.append(handler)
    
    # Add server error handler
    error_handlers.append('''
if response.status_code >= 500:
    raise Cache__Client__Error__Server(f"Server error: {response.status_code}")
''')
    
    return '\n'.join(error_handlers)

def _generate_endpoint_method_simplified(self, endpoint: Schema__Endpoint__Contract) -> str:
    """Generate simplified method with Type_Safe validation"""
    
    # Build the method template
    template = f'''
def {endpoint.route_method}(self{self._build_params_string(endpoint)}) -> {endpoint.response_schema.__name__}:
    """
    All parameters are Type_Safe validated before this method is called.
    No validation errors possible - Type_Safe ensures data is valid.
    """
    
    # Build path - we know all params are valid
    path = "{endpoint.path_pattern}".format(**locals())
    
    # Execute request - no validation needed
    response = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    # Only handle actual runtime errors
    {self._generate_error_handling_ast(endpoint)}
    
    # Success - deserialize response
    return {endpoint.response_schema.__name__}.from_json(response.json())
'''
    return template
```

### Contract Extraction Focuses on Actual Errors

The contract extractor now identifies only the errors that matter:

```python
def _extract_actual_error_codes(self, func_ast: Ast_Module) -> List[int]:
    """Extract only non-validation error codes from function"""
    
    actual_errors = []
    
    with Ast_Visit(func_ast) as visitor:
        visitor.capture('Ast_Raise')
        visitor.visit()
        
        for raise_node in visitor.captured_nodes()['Ast_Raise']:
            if self._is_http_exception(raise_node):
                status_code = self._extract_status_code(raise_node)
                
                # Skip validation errors - Type_Safe handles these
                if status_code not in [400, 422]:
                    actual_errors.append(status_code)
                    
                    # Log what kind of error this is
                    if status_code == 404:
                        self.log("Found: Resource not found error")
                    elif status_code == 401:
                        self.log("Found: Authentication error")
                    elif status_code == 409:
                        self.log("Found: Business logic conflict")
    
    return actual_errors
```

## Testing Strategy

### Test Structure Following Type_Safe and OSBot Patterns

Tests leverage the three execution modes and OSBot's testing patterns:

```python
from unittest import TestCase
from osbot_utils.testing.__ import __, __SKIP__

class test_Cache__Client(TestCase):
    
    @classmethod
    def setUpClass(cls):
        """Expensive setup once for all tests (OSBot pattern)"""
        # Create service once
        cls.fast_api = Cache__Service__Fast_API()
        cls.fast_api.setup()
        cls.app = cls.fast_api.app()
    
    def test_transparent_modes(self):
        """Test that all three modes work transparently"""
        
        test_data = {"key": "value"}
        
        # Test remote mode
        if os.getenv("CACHE_SERVICE_URL"):
            client_remote = Cache__Client(
                config=Cache__Client__Config(
                    target_server=os.getenv("CACHE_SERVICE_URL")
                )
            )
            result_remote = client_remote.file().store().store_json(test_data)
            assert isinstance(result_remote, Schema__Store__Response)
        
        # Test in-memory mode (fastest for unit tests)
        client_memory = Cache__Client(_app=self.app)
        result_memory = client_memory.file().store().store_json(test_data)
        assert isinstance(result_memory, Schema__Store__Response)
        
        # Test local server mode (real HTTP)
        with Fast_API_Server(app=self.app) as server:
            client_local = Cache__Client(_server=server)
            result_local = client_local.file().store().store_json(test_data)
            assert isinstance(result_local, Schema__Store__Response)
        
        # All three modes return the same type!
    
    def test_module_structure_mirrors_service(self):
        """Test that client structure matches service structure"""
        
        with Cache__Client(app=self.app) as client:
            # Main modules
            assert hasattr(client, 'admin')
            assert hasattr(client, 'data')
            assert hasattr(client, 'file')
            assert hasattr(client, 'zip')
            
            # File sub-operations
            file_client = client.file()
            assert hasattr(file_client, 'store')
            assert hasattr(file_client, 'retrieve')
            assert hasattr(file_client, 'delete')
            assert hasattr(file_client, 'exists')
            
            # Methods match Routes__* methods exactly
            store_client = file_client.store()
            assert hasattr(store_client, 'store_json')
            assert hasattr(store_client, 'store_bytes')
```

## CI/CD Integration

### Contract Validation Pipeline

The CI pipeline ensures contracts stay synchronized:

```yaml
# .github/workflows/contract-validation.yml
name: Contract Validation

on:
  pull_request:
    paths:
      - 'mgraph_ai_service_cache/fast_api/routes/**'

jobs:
  validate_contract:
    runs-on: ubuntu-latest
    steps:
      - name: Extract Current Contract using OSBot AST
        run: |
          python -m mgraph_ai_service_cache_client.contract.extract \
            --service-path ../mgraph_ai_service_cache \
            > contract_new.json
      
      - name: Compare Contracts using OSBot AST
        run: |
          python -m mgraph_ai_service_cache_client.contract.compare \
            contract/contract.json contract_new.json \
            --use-osbot-ast
      
      - name: Generate Client if Changed
        if: steps.compare.outputs.changed == 'true'
        run: |
          python -m mgraph_ai_service_cache_client.contract.generate \
            --contract contract_new.json \
            --output client/ \
            --generator osbot-ast
      
      - name: Run Contract Tests with All Modes
        run: |
          # Test in-memory mode
          pytest tests/test_contract_compliance.py -m in_memory
          
          # Test local server mode
          pytest tests/test_contract_compliance.py -m local_server
          
          # Test remote mode if configured
          if [ -n "$CACHE_SERVICE_URL" ]; then
            pytest tests/test_contract_compliance.py -m remote
          fi
```

### Automated Client Updates Using OSBot AST

```python
class Client__Updater(Type_Safe):
    """Automated client updater using OSBot AST infrastructure"""
    
    def update_if_needed(self) -> bool:
        """Check for contract changes and update client using OSBot AST"""
        
        # Extract current contract using OSBot AST
        extractor = Contract__Extractor(service_path=self.service_path)
        current_contract = extractor.extract_contract()
        
        # Load stored contract
        stored_contract = self.load_stored_contract()
        
        # Compare using OSBot AST comparison
        comparator = Contract__Comparator()
        diff = comparator.compare_with_ast_analysis(stored_contract, current_contract)
        
        if diff.has_changes():
            # Generate new client code using OSBot AST
            generator = AST__Client__Generator(contract=current_contract)
            generated_files = generator.generate_client()
            
            # Write generated files preserving OSBot structure
            for filepath, content in generated_files.items():
                self.write_file_preserving_structure(filepath, content)
            
            # Update stored contract
            self.save_contract(current_contract)
            
            # Run tests to validate
            self.run_validation_tests()
            
            return True
        
        return False
```

## Performance Optimizations

### Connection Pooling for Remote Mode

The remote mode uses optimized session management:

```python
class Cache__Client__Requests__Remote__Optimized(Cache__Client__Requests):
    """Optimized remote request handling"""
    
    def _configure_session(self):
        """Configure session with connection pooling and retry logic"""
        
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        
        # Configure retry strategy
        retry = Retry(
            total=3,
            backoff_factor=0.3,
            status_forcelist=[500, 502, 503, 504]
        )
        
        # Configure connection pooling
        adapter = HTTPAdapter(
            max_retries=retry,
            pool_connections=10,
            pool_maxsize=20,
            pool_block=False
        )
        
        self._session.mount('http://', adapter)
        self._session.mount('https://', adapter)
        
        # Set default timeout
        self._session.timeout = 30

### Caching for Immutable Operations

Leverage OSBot's @cache_on_self for immutable operations:

```python
class Cache__Client__File__Retrieve:
    
    @cache_on_self
    def retrieve_by_hash(self, cache_hash: Safe_Str__Hash) -> Schema__Cache__Item:
        """Cache results for immutable hash lookups"""
        # Hash-based retrieval is immutable - same hash always returns same data
        return self._retrieve_by_hash_impl(cache_hash)
```

## Implementation Checklist

- [ ] **OSBot AST Integration** - Extend OSBot AST classes for client generation
- [ ] **Contract Schema** - Define Type_Safe contract schemas with route structure
- [ ] **Contract Extraction** - Use Ast_Visit to extract from Routes__* classes  
- [ ] **AST Generator** - Build generator using Ast_Module, Ast_Merge, Ast_Function_Def
- [ ] **Transparent Modes** - Implement Cache__Client__Requests with three modes
- [ ] **Module Structure** - Generate client structure mirroring service routes
- [ ] **Method Naming** - Use exact same method names as Routes__* classes
- [ ] **Error Handling** - Create typed exception hierarchy with Type_Safe schemas
- [ ] **Generated Code** - Generate initial client from contract using OSBot AST
- [ ] **Tests** - Write tests for all three transparent modes
- [ ] **CI Pipeline** - Set up contract validation with OSBot AST tools
- [ ] **Documentation** - Generate client docs from OSBot AST info() data
- [ ] **Performance** - Add connection pooling and @cache_on_self
- [ ] **Versioning** - Implement semantic versioning based on AST diff analysis

## Summary

This implementation guide provides a complete blueprint for building contract-driven FastAPI clients that leverage both FastAPI's runtime route information and OSBot-Utils AST infrastructure:

1. **Hybrid Contract Extraction**: Use FastAPI's actual route objects for paths/methods + OSBot AST for internal analysis
2. **Type_Safe Validation Eliminates Server Errors**: Client-side validation means 400/422 errors are impossible
3. **OSBot AST classes** provide clean abstractions over raw Python AST
4. **Three transparent execution modes** via unified request handling
5. **Exact service structure mirroring** with Routes__* → Cache__Client__* mapping
6. **Same method names** preserved from service to client
7. **Simplified error handling** - only handle actual runtime errors (404, 401, 409, 500+)
8. **Clean code generation** with Ast_Merge and structured node manipulation
9. **Faster failure** - validation errors caught client-side, no network round-trip
10. **Smaller, simpler clients** - no validation error handling code needed

The critical insight is that **Type_Safe on the client makes validation errors impossible**, dramatically simplifying the generated client code. Combined with FastAPI's runtime route information, we get perfect contract extraction without guessing, and cleaner clients that fail fast and provide better error messages.

The approach eliminates manual client maintenance while providing:
- **Zero invalid network traffic** - Type_Safe blocks bad data before requests
- **Immediate validation feedback** - No waiting for server round-trips
- **Simpler generated code** - No 400/422 error handling needed
- **Perfect route accuracy** - Using FastAPI's actual routes, not guessing from names
- **Complete type safety** - Through the entire request/response lifecycle