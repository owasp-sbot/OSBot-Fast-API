# FastAPI Service Client Implementation Guide: Contract-Driven AST Generation
*Version v0.26.9 - September 29, 2025*

## Executive Summary

This document defines a contract-driven approach for automatically generating Python clients for FastAPI services using a hybrid of FastAPI's runtime route information and OSBot-Utils AST infrastructure. The approach leverages Type_Safe schemas as contracts and combines FastAPI's actual route registry (for accurate paths and methods) with OSBot AST analysis (for detecting internal logic like exception handling).

A critical insight is that **Type_Safe validation on the client eliminates entire categories of server errors**. When both client and server use Type_Safe, validation errors (400/422) become impossible - invalid data is caught at assignment time on the client, before any network request. This dramatically simplifies the generated client code, eliminates unnecessary error handling, and provides faster failure with better error messages.

The generated clients support three transparent execution modes (remote, in-memory, local server) through a unified request handling layer, with the execution mode completely invisible to the client code.

## Core Architecture Decisions

### 1. Contract as Source of Truth

The **Service Contract** is a Type_Safe schema that captures the complete interface between client and server. This contract serves as the single source of truth for generating client code, ensuring perfect alignment between service and client.

**Why contracts matter**: Traditional approaches require manual synchronization between service and client code. When a service endpoint changes, developers must remember to update all client code. Contracts eliminate this manual process by defining the interface once and generating both validation and client code from that single definition.

**How it works in practice**: When you change a route in your FastAPI service (say, adding a new parameter or changing a return type), the contract extractor automatically detects this change. It then regenerates the client code with the updated signature. This means:
- No forgotten updates in client code
- No mismatched types between client and server
- No manual documentation updates needed
- Changes are automatically propagated through CI/CD

**Implementation details**: The contract is extracted using a two-phase approach:
1. **FastAPI Runtime Extraction**: We query FastAPI's route registry to get the actual paths, HTTP methods, and parameter names
2. **AST Enhancement**: We analyze the route method's source code to find exception handling, return types, and business logic

This hybrid approach ensures the contract always reflects reality, not what we think or document the API to be.

### 2. OSBot-Utils AST-Based Code Generation

Instead of working with raw Python AST nodes (which are difficult to manipulate and reason about), we use OSBot-Utils' AST abstraction layer. This provides several critical advantages:

**Structured node representation**: Each AST node type has a dedicated class (`Ast_Function_Def`, `Ast_Class_Def`, etc.) with an `info()` method that returns structured, Type_Safe-compatible data. This makes it easy to inspect and modify AST structures programmatically.

**Clean traversal patterns**: The `Ast_Visit` class implements the visitor pattern for AST traversal, with built-in support for capturing specific node types. This simplifies complex operations like finding all route methods in a service.

**Module composition**: The `Ast_Merge` class allows building complex Python files incrementally by merging AST modules. This is perfect for generating client code where we need to combine imports, base classes, and multiple method definitions.

### 3. Three Transparent Execution Modes

All clients support three execution modes that are **completely transparent to the client code**. The client doesn't know or care which mode is active - it just calls methods and gets results. This transparency is achieved through a dedicated request handling layer (`Cache__Client__Requests` pattern).

**Mode implementation**: The execution mode is determined at client initialization and handled entirely within the request layer:

```python
class Cache__Client__Requests(Type_Safe):
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None          # FastAPI app for in-memory
    _server      : Optional[Fast_API_Server] = None  # Local server instance
    _session     : Optional[requests.Session] = None # HTTP session for remote
    
    def execute(self, method: str, path: str, body: Any = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on current mode"""
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            # Use FastAPI TestClient
            return self._execute_in_memory(method, path, body)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            # Use local Fast_API_Server instance
            return self._execute_local_server(method, path, body)
        else:
            # Use requests library for remote calls
            return self._execute_remote(method, path, body)
```

**Why transparency matters**: Tests can run against in-memory mode for speed, integration tests can use local server mode for HTTP validation, and production uses remote mode - all without changing a single line of client code.

## Contract Schema Definition

The contract system defines the complete interface between client and server using Type_Safe schemas. These aren't just data structures - they're a formal specification that drives code generation, validation, and testing.

### Core Contract Types

Each contract type serves a specific purpose in defining the service interface. Let's understand what each one does and why it's needed:

```python
from enum import Enum
from typing import Type, Optional, List, Dict, Any
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version import Safe_Str__Version
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

class Enum__Http__Method(str, Enum):
    GET    = "GET"
    POST   = "POST"
    PUT    = "PUT"
    DELETE = "DELETE"
    PATCH  = "PATCH"

class Enum__Param__Location(str, Enum):
    PATH   = "path"      # Parameters in URL path: /users/{id}
    QUERY  = "query"     # Parameters after ?: /users?limit=10
    HEADER = "header"    # Parameters in HTTP headers
    BODY   = "body"      # Request body content

class Enum__Client__Mode(str, Enum):
    REMOTE       = "remote"        # HTTP calls to deployed service
    IN_MEMORY    = "in_memory"     # FastAPI TestClient (same process)
    LOCAL_SERVER = "local_server"  # Fast_API_Server (local HTTP server)
```

**Schema__Endpoint__Param** defines a single parameter for an endpoint. This could be a path parameter (like `{user_id}` in `/users/{user_id}`), a query parameter (like `limit` in `/users?limit=10`), or a header. Each parameter knows:
- Its name and location
- Its Type_Safe type (for validation)
- Whether it's required or optional
- Any default value

```python
class Schema__Endpoint__Param(Type_Safe):
    name         : Safe_Str__Id                      # Parameter name
    location     : Enum__Param__Location             # Where parameter appears
    param_type   : Type[Type_Safe]                   # Actual Type_Safe class reference
    required     : bool = True                       # Is parameter required?
    default      : Optional[Any] = None              # Default value if any
    description  : Optional[Safe_Str__Text] = None   # Parameter documentation
```

**Schema__Endpoint__Contract** represents a single API endpoint. It contains everything needed to generate a client method:
- The actual HTTP path and method (from FastAPI)
- The original route class and method names (for code organization)
- All parameters with their types and locations
- Request and response schemas (Type_Safe classes)
- Expected error codes (from AST analysis)

```python
class Schema__Endpoint__Contract(Type_Safe):
    # Endpoint identity - what FastAPI tells us
    operation_id : Safe_Str__Id                      # Unique operation identifier
    method       : Enum__Http__Method                # HTTP method
    path_pattern : Safe_Str__File__Path              # URL pattern with {params}
    
    # Route class mapping - how the service organizes code
    route_class  : Safe_Str__Id                      # e.g., "Routes__File__Store"
    route_method : Safe_Str__Id                      # Original method name in route
    route_module : Optional[Safe_Str__Id] = None     # Module path (e.g., "file", "admin")
    
    # Parameters - extracted from function signature
    path_params  : List[Schema__Endpoint__Param] = []
    query_params : List[Schema__Endpoint__Param] = []
    header_params: List[Schema__Endpoint__Param] = []
    
    # Request/Response schemas - Type_Safe classes for data
    request_schema : Optional[Type[Type_Safe]] = None      # Request body Type_Safe class
    response_schema: Optional[Type[Type_Safe]] = None      # Response Type_Safe class
    
    # Error handling - from AST analysis
    error_schemas: Dict[int, Type[Type_Safe]] = {}   # Status code -> Error schema
```

**Schema__Routes__Module** groups related endpoints together. This matches how the service organizes its routes into modules (file operations, admin functions, etc.). This organization is preserved in the generated client:

```python
class Schema__Routes__Module(Type_Safe):
    """Represents a module of routes (e.g., 'file', 'admin', 'data')"""
    module_name  : Safe_Str__Id                      # e.g., "file", "admin"
    route_classes: List[Safe_Str__Id]                # e.g., ["Routes__File__Store", "Routes__File__Retrieve"]
    endpoints    : List[Schema__Endpoint__Contract]  # All endpoints in this module
```

**Schema__Service__Contract** is the complete contract for the entire service. It contains all modules and endpoints, plus metadata about versions and generation time:

```python
class Schema__Service__Contract(Type_Safe):
    service_name : Safe_Str__Id                      # Service identifier
    version      : Safe_Str__Version                 # Contract version
    base_path    : Safe_Str__File__Path = ""         # Base URL path
    modules      : List[Schema__Routes__Module]      # Organized route modules
    endpoints    : List[Schema__Endpoint__Contract]  # All service endpoints (flat list)
    
    # Metadata for tracking and versioning
    generated_at    : Timestamp_Now                  # When contract was generated
    service_version : Safe_Str__Version              # Version of service
    client_version  : Safe_Str__Version              # Minimum client version required
```

### Contract Storage Structure

The contract and generated code follow a structure that mirrors the service organization:

```
mgraph_ai_service_cache_client/
├── contract/
│   ├── contract.json                  # Current contract (serialized)
│   ├── contract_history/              # Previous versions for comparison
│   │   └── contract_v0.5.64.json
│   ├── contract_schema.py             # Type_Safe schema definitions
│   └── contract_extractor.py          # Extract contract from service
├── client/
│   ├── Cache__Client.py               # Main client class
│   ├── Cache__Client__Config.py       # Configuration
│   ├── Cache__Client__Requests.py     # Request handling (3 modes)
│   ├── admin/
│   │   └── Cache__Client__Admin__Storage.py
│   ├── data/
│   │   ├── Cache__Client__Data__Delete.py
│   │   ├── Cache__Client__Data__Retrieve.py
│   │   └── Cache__Client__Data__Store.py
│   ├── file/
│   │   ├── Cache__Client__File__Delete.py
│   │   ├── Cache__Client__File__Exists.py
│   │   ├── Cache__Client__File__Retrieve.py
│   │   └── Cache__Client__File__Store.py
│   └── zip/
│       └── Cache__Client__Zip.py
```

## OSBot-Utils AST-Based Code Generation

### AST Generator Architecture Using OSBot-Utils

The generator leverages OSBot-Utils' AST infrastructure to create clean, maintainable client code. Instead of manipulating raw AST nodes (which are difficult to work with and error-prone), we use structured classes that provide intuitive interfaces.

**Why use OSBot AST instead of raw Python AST?**
- **Structured data**: Each node has an `info()` method returning Type_Safe-compatible dictionaries
- **Clean traversal**: The `Ast_Visit` class provides visitor pattern for finding specific nodes
- **Module composition**: `Ast_Merge` allows building complex files incrementally
- **Error recovery**: If AST parsing fails, we can continue with partial information
- **Testing friendly**: Can inspect and validate AST structure before generating code

Here's how the generator works step by step:

```python
from pathlib import Path
from typing import Dict, List
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
from osbot_utils.helpers.ast.nodes.Ast_Class_Def import Ast_Class_Def
from osbot_utils.helpers.ast.nodes.Ast_Function_Def import Ast_Function_Def

class AST__Client__Generator(Type_Safe):
    contract     : Schema__Service__Contract
    output_dir   : Path
    
    def generate_client(self) -> Dict[str, str]:
        """Generate complete client from contract using OSBot AST"""
        
        generated_files = {}
        
        # Step 1: Generate the main client class
        # This is the entry point that users interact with
        main_client = self._generate_main_client()
        generated_files['client/Cache__Client.py'] = main_client
        
        # Step 2: Generate module-specific client classes
        # Each module (file, admin, data) gets its own set of classes
        for module in self.contract.modules:
            module_files = self._generate_module_clients(module)
            generated_files.update(module_files)
        
        # Step 3: Generate the request handler
        # This handles the three execution modes transparently
        request_handler = self._generate_request_handler()
        generated_files['client/Cache__Client__Requests.py'] = request_handler
        
        return generated_files
```

**The Main Client Generation Process**:

The main client class serves as the entry point. It provides accessor methods for each module (like `file()`, `admin()`, `data()`). Here's what happens:

1. We start with a template that has the basic structure
2. Parse it into an AST using `Ast_Module`
3. Use `Ast_Visit` to find the class definition
4. Add methods for each module dynamically
5. Convert back to source code

```python
    def _generate_main_client(self) -> str:
        """Generate the main Cache__Client class"""
        
        # Start with a template containing imports and basic structure
        template = '''
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.decorators.methods.cache_on_self import cache_on_self
from mgraph_ai_service_cache_client.client.Cache__Client__Config import Cache__Client__Config
from mgraph_ai_service_cache_client.client.Cache__Client__Requests import Cache__Client__Requests

class Cache__Client(Type_Safe):
    config   : Cache__Client__Config
    _requests: Cache__Client__Requests = None
'''
        
        # Parse template into AST - this gives us a structured representation
        ast_module = Ast_Module(template)
        
        # Find the class definition using Ast_Visit
        # This visitor pattern makes it easy to find specific node types
        with Ast_Visit(ast_module) as visitor:
            visitor.capture('Ast_Class_Def')  # Capture all class definitions
            visitor.visit()                    # Traverse the AST
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
        
        # Add module accessor methods
        # For each module (file, admin, data), add a method that returns the module client
        for module in self.contract.modules:
            method_ast = self._create_module_accessor(module.module_name)
            class_node.node.body.append(method_ast.node)
        
        # Add request handler accessor
        # This provides access to the unified request handling
        requests_method = self._create_requests_accessor()
        class_node.node.body.append(requests_method.node)
        
        # Convert the modified AST back to Python source code
        return ast_module.source_code()
```

**Module Client Generation**:

For each module (like 'file', 'admin'), we generate client classes that mirror the service structure. Each `Routes__*` class becomes a `Cache__Client__*` class:

```python
    def _generate_module_clients(self, module: Schema__Routes__Module) -> Dict[str, str]:
        """Generate client classes for a specific module (e.g., file, admin)
        
        This creates classes like:
        - Cache__Client__File__Store (from Routes__File__Store)
        - Cache__Client__File__Retrieve (from Routes__File__Retrieve)
        """
        
        files = {}
        
        for route_class in module.route_classes:
            # Transform the name: Routes__File__Store -> Cache__Client__File__Store
            client_class_name = route_class.replace('Routes__', 'Cache__Client__')
            
            # Get all endpoints that belong to this route class
            endpoints = [e for e in module.endpoints if e.route_class == route_class]
            
            # Generate the client class with all its methods
            class_code = self._generate_route_client_class(client_class_name, endpoints)
            
            # Determine the file path based on module structure
            # This preserves the service's organization
            if module.module_name:
                file_path = f'client/{module.module_name}/{client_class_name}.py'
            else:
                file_path = f'client/{client_class_name}.py'
            
            files[file_path] = class_code
        
        return files
```

```python    
    def _generate_route_client_class(self, class_name: str, endpoints: List[Schema__Endpoint__Contract]) -> str:
        """Generate a client class for a specific Routes__* class"""
        
        # Create AST merger for building the module
        merger = Ast_Merge()
        
        # Add imports
        imports_code = self._generate_imports_for_endpoints(endpoints)
        merger.merge_module(Ast_Module(imports_code))
        
        # Create class with Type_Safe base
        class_template = f"""
class {class_name}(Type_Safe):
    _cache_client: Any  # Reference to parent Cache__Client
    
    @property
    def requests(self):
        return self._cache_client.requests()
"""
        class_module = Ast_Module(class_template)
        
        # Add method for each endpoint
        with Ast_Visit(class_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
            
            for endpoint in endpoints:
                method_node = self._generate_endpoint_method(endpoint)
                class_node.node.body.append(method_node.node)
        
        merger.merge_module(class_module)
        return merger.source_code()
```

```python        
    def _generate_endpoint_method(self, endpoint: Schema__Endpoint__Contract) -> Ast_Function_Def:
        """Generate a method for a specific endpoint using OSBot AST"""
        
        # Build method template based on endpoint
        method_name = endpoint.route_method  # Use the same name as in Routes__* class
        
        # Build parameter list
        params_str = self._build_params_string(endpoint)
        
        # Build return type annotation
        return_type = self._get_return_type_string(endpoint)
        
        # Create method template
        template = f"""
def {method_name}(self{params_str}) -> {return_type}:
    """Auto-generated from {endpoint.operation_id}"""
    path = self._build_path("{endpoint.path_pattern}", locals())
    
    result = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    if result.status_code != 200:
        self._handle_error(result, {endpoint.error_schemas})
    
    if result.json:
        return {return_type}.from_json(result.json)
    return result.content
"""
        
        # Parse and return as Ast_Function_Def
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

```python        
    def _create_module_accessor(self, module_name: str) -> Ast_Function_Def:
        """Create a @cache_on_self method to access a module's client"""
        
        client_class = f"Cache__Client__{module_name.title()}"
        
        template = f"""
@cache_on_self
def {module_name}(self) -> {client_class}:
    """Access {module_name} operations"""
    from mgraph_ai_service_cache_client.client.{module_name}.{client_class} import {client_class}
    return {client_class}(_cache_client=self)
"""
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

### Method Generation with OSBot AST

The method generation process is where we create the actual client methods that developers will call. Each method corresponds to an endpoint in the service, with the same name and parameters. The OSBot AST infrastructure makes this process clean and maintainable.

**The Process Step by Step**:

1. **Start with the endpoint contract** - This tells us everything about the method we need to generate
2. **Build the method structure** - Create the function definition with proper parameters and return type
3. **Generate the body** - Create the code that builds the path, executes the request, and handles errors
4. **Optimize for Type_Safe** - Since validation happens client-side, the body is simple

Here's how each client class is generated:

```python
    def _generate_route_client_class(self, class_name: str, endpoints: List[Schema__Endpoint__Contract]) -> str:
        """Generate a client class for a specific Routes__* class
        
        For example, this might generate Cache__Client__File__Store with methods like:
        - store_json()
        - store_bytes()
        - store_file()
        
        Each method will have the exact same name as in the Routes__File__Store class
        """
        
        # Create AST merger for building the module incrementally
        merger = Ast_Merge()
        
        # Step 1: Generate imports based on what the endpoints need
        imports_code = self._generate_imports_for_endpoints(endpoints)
        merger.merge_module(Ast_Module(imports_code))
        
        # Step 2: Create the class structure with Type_Safe base
        class_template = f'''
class {class_name}(Type_Safe):
    _cache_client: Any  # Reference to parent Cache__Client
    
    @property
    def requests(self):
        """Access the unified request handler"""
        return self._cache_client.requests()
'''
        class_module = Ast_Module(class_template)
        
        # Step 3: Add a method for each endpoint
        with Ast_Visit(class_module) as visitor:
            visitor.capture('Ast_Class_Def')
            visitor.visit()
            class_node = visitor.captured_nodes()['Ast_Class_Def'][0]
            
            for endpoint in endpoints:
                # Generate the method AST node
                method_node = self._generate_endpoint_method(endpoint)
                # Add it to the class body
                class_node.node.body.append(method_node.node)
        
        # Step 4: Merge everything and return the source code
        merger.merge_module(class_module)
        return merger.source_code()
```

**Individual Method Generation**:

Each method is generated from its endpoint contract. The key insight here is that with Type_Safe validation on the client, these methods are very simple - they just need to format the path, make the request, and handle real errors (not validation):

```python
    def _generate_endpoint_method(self, endpoint: Schema__Endpoint__Contract) -> Ast_Function_Def:
        """Generate a method for a specific endpoint using OSBot AST
        
        The generated method will:
        1. Use the exact same name as the service method
        2. Accept Type_Safe validated parameters
        3. Build the path from parameters
        4. Execute the request transparently
        5. Handle only real errors (404, 401, etc)
        6. Return the Type_Safe response object
        """
        
        # Use the exact same method name as in the Routes class
        method_name = endpoint.route_method  
        
        # Build parameter list from the contract
        params_str = self._build_params_string(endpoint)
        
        # Get the return type from the contract
        return_type = self._get_return_type_string(endpoint)
        
        # Create the method template
        # Note how simple this is - no validation needed!
        template = f'''
def {method_name}(self{params_str}) -> {return_type}:
    """Auto-generated from {endpoint.operation_id}
    
    All parameters are Type_Safe validated before this method is called.
    No validation errors possible - Type_Safe ensures data is valid.
    """
    
    # Build path - we know all params are valid Type_Safe objects
    path = self._build_path("{endpoint.path_pattern}", locals())
    
    # Execute request through transparent handler
    result = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    # Handle only real runtime errors (not validation)
    if result.status_code == 404:
        raise Cache__Client__Error__Not_Found(f"Resource not found: {{path}}")
    elif result.status_code == 401:
        raise Cache__Client__Error__Unauthorized("Authentication failed")
    elif result.status_code >= 500:
        raise Cache__Client__Error__Server(f"Server error: {{result.status_code}}")
    
    # Success - deserialize to Type_Safe response
    if result.json:
        return {return_type}.from_json(result.json)
    return result.content
'''
        
        # Parse the template and return as Ast_Function_Def
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

**Module Accessor Methods**:

The main client needs methods to access each module. These use the `@cache_on_self` decorator to ensure we only create one instance per module:

```python
    def _create_module_accessor(self, module_name: str) -> Ast_Function_Def:
        """Create a @cache_on_self method to access a module's client
        
        For example, this creates the file() method that returns Cache__Client__File
        """
        
        client_class = f"Cache__Client__{module_name.title()}"
        
        template = f'''
@cache_on_self
def {module_name}(self) -> {client_class}:
    """Access {module_name} operations
    
    This returns a client for all {module_name}-related operations.
    The @cache_on_self ensures we only create one instance.
    """
    from mgraph_ai_service_cache_client.client.{module_name}.{client_class} import {client_class}
    return {client_class}(_cache_client=self)
'''
        module = Ast_Module(template)
        with Ast_Visit(module) as visitor:
            visitor.capture_functions()
            visitor.visit()
            return visitor.captured_nodes()['Ast_Function_Def'][0]
```

## Client Implementation Architecture

### Transparent Request Handling

The key to transparent execution modes is the `Cache__Client__Requests` class, which handles all HTTP communication regardless of the underlying execution mode. This pattern ensures client code never needs to know about the execution context.

**The Magic of Transparency**:

When a developer writes `client.file().store().store_json(data)`, they don't need to know or care whether:
- The request goes over the network to a production server (REMOTE mode)
- It's handled by an in-process FastAPI TestClient (IN_MEMORY mode)
- It goes to a local HTTP server for integration testing (LOCAL_SERVER mode)

This transparency is crucial for:
- **Testing**: Unit tests can run in IN_MEMORY mode (milliseconds per test)
- **Integration**: Integration tests can use LOCAL_SERVER mode (real HTTP, but local)
- **Production**: The exact same code works with REMOTE mode
- **Debugging**: Can switch modes without changing client code

Here's the complete implementation that makes this magic happen:

```python
from typing import Any, Optional, Dict
from enum import Enum
import requests
from fastapi.testclient import TestClient
from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Cache__Client__Requests(Type_Safe):
    """Unified request handler supporting three transparent execution modes
    
    This class is the heart of the client's flexibility. It abstracts away
    the execution mode, providing a single interface for all requests.
    """
    
    config       : Cache__Client__Config
    mode         : Enum__Client__Mode = Enum__Client__Mode.REMOTE
    _app         : Optional[Any] = None              # FastAPI app for in-memory
    _server      : Optional[Fast_API_Server] = None  # Local server instance
    _test_client : Optional[TestClient] = None       # In-memory client
    _session     : Optional[requests.Session] = None # HTTP session for remote
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._setup_mode()
    
    def _setup_mode(self):
        """Initialize the appropriate execution backend
        
        This method determines which mode to use based on what was provided
        during initialization. The mode is completely transparent to callers.
        """
        
        if self._app:
            # In-memory mode: FastAPI TestClient runs the app in the same process
            # This is the fastest mode - no network overhead, no serialization
            self.mode = Enum__Client__Mode.IN_MEMORY
            self._test_client = TestClient(self._app)
            
        elif self._server:
            # Local server mode: Real HTTP server on localhost
            # This tests actual HTTP behavior while keeping tests isolated
            self.mode = Enum__Client__Mode.LOCAL_SERVER
            if not isinstance(self._server, Fast_API_Server):
                self._server = Fast_API_Server(app=self._server)
            
        else:
            # Remote mode: Normal HTTP requests to deployed service
            # This is production mode - real network, real server
            self.mode = Enum__Client__Mode.REMOTE
            self._session = requests.Session()
            self._configure_session()
```

```python        
    def execute(self, method: str, path: str, body: Any = None, 
                headers: Optional[Dict] = None) -> Cache__Client__Requests__Result:
        """Execute request transparently based on mode
        
        This is the single entry point for all requests. The client methods
        call this, and it handles routing to the appropriate backend.
        
        Args:
            method: HTTP method (GET, POST, etc)
            path: URL path (e.g., "/file/store/json")
            body: Request body (will be JSON serialized)
            headers: Additional headers
            
        Returns:
            Unified result object regardless of execution mode
        """
        
        # Add authentication headers (same for all modes)
        headers = {**self.auth_headers(), **(headers or {})}
        
        # Execute based on mode - completely transparent to caller
        if self.mode == Enum__Client__Mode.IN_MEMORY:
            response = self._execute_in_memory(method, path, body, headers)
        elif self.mode == Enum__Client__Mode.LOCAL_SERVER:
            response = self._execute_local_server(method, path, body, headers)
        else:
            response = self._execute_remote(method, path, body, headers)
        
        # Convert to unified result format
        # This ensures all modes return the same structure
        return self._build_result(response, path)
```

```python        
    def _execute_in_memory(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using FastAPI TestClient (same process, no HTTP)
        
        This mode:
        - Runs in the same Python process
        - No network overhead
        - No serialization/deserialization overhead
        - Perfect for unit tests (milliseconds per test)
        - Can access app state directly for testing
        """
        
        method_func = getattr(self._test_client, method.lower())
        if body:
            return method_func(path, json=body, headers=headers)
        else:
            return method_func(path, headers=headers)
```

```python        
    def _execute_local_server(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using local Fast_API_Server (real HTTP, localhost)
        
        This mode:
        - Starts a real HTTP server on localhost
        - Tests actual HTTP behavior (headers, status codes)
        - Still isolated from external dependencies
        - Good for integration tests
        - Can test timeouts, connection issues
        """
        
        url = f"{self._server.base_url()}{path}"
        method_func = getattr(requests, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
```

```python        
    def _execute_remote(self, method: str, path: str, body: Any, headers: Dict):
        """Execute using requests to remote service
        
        This mode:
        - Real network requests to deployed service
        - Production mode
        - Can hit staging or production servers
        - Subject to network latency, failures
        - Uses session for connection pooling
        """
        
        url = f"{self.config.target_server}{path}"
        method_func = getattr(self._session, method.lower())
        
        if body:
            return method_func(url, json=body, headers=headers)
        else:
            return method_func(url, headers=headers)
```

```python        
    def _build_result(self, response, path) -> Cache__Client__Requests__Result:
        """Convert any response type to unified result
        
        This ensures that regardless of the execution mode, the client
        methods always get the same result structure to work with.
        """
        
        return Cache__Client__Requests__Result(
            status_code=response.status_code,
            json=response.json() if response.headers.get('content-type', '').startswith('application/json') else None,
            text=response.text if response.headers.get('content-type', '').startswith('text/') else None,
            content=response.content,
            headers=dict(response.headers),
            path=path,
            duration=getattr(response, 'elapsed', None)
        )
```

### Module Organization Following Service Structure

The client structure exactly mirrors the service's route organization. Each `Routes__*` class becomes a `Cache__Client__*` class with the same method names. This mirroring is crucial for maintainability - developers can navigate between service and client code intuitively.

**Why Mirror the Service Structure?**

1. **Intuitive Navigation**: If you're looking at `Routes__File__Store.store_json()` in the service, you know the client has `Cache__Client__File__Store.store_json()`
2. **Automatic Organization**: The generator preserves the service's folder structure automatically
3. **Easier Debugging**: Stack traces show matching method names between client and service
4. **Team Familiarity**: Developers working on the service instantly understand the client structure

Here's how the organization works in practice:

```python
class Cache__Client:
    """Main client with module accessors matching service structure
    
    This is the entry point that developers interact with. It provides
    clean access to all modules through methods that return specialized
    clients for each area of functionality.
    """
    
    @cache_on_self
    def admin(self) -> Cache__Client__Admin:
        """Access admin operations (Routes__Admin__* methods)
        
        The @cache_on_self decorator ensures we create only one instance
        of the admin client, reusing it for all subsequent calls.
        """
        return Cache__Client__Admin(_cache_client=self)
    
    @cache_on_self
    def data(self) -> Cache__Client__Data:
        """Access data operations (Routes__Data__* methods)
        
        This provides access to all data-related operations like
        store, retrieve, delete for the data module.
        """
        return Cache__Client__Data(_cache_client=self)
    
    @cache_on_self
    def file(self) -> Cache__Client__File:
        """Access file operations (Routes__File__* methods)
        
        File operations are further organized into sub-clients for
        store, retrieve, delete, and exists operations.
        """
        return Cache__Client__File(_cache_client=self)
    
    @cache_on_self
    def zip(self) -> Cache__Client__Zip:
        """Access zip operations (Routes__Zip methods)
        
        ZIP-specific operations for compressed file handling.
        """
        return Cache__Client__Zip(_cache_client=self)
```

**Module Clients - Second Level Organization**:

Some modules have multiple route classes. For example, the 'file' module might have separate classes for different operations. The client mirrors this:

```python
class Cache__Client__File:
    """Groups all file-related route clients
    
    This intermediate client provides access to all file operations,
    organized exactly as they are in the service. Each method returns
    a specific client that contains the actual operation methods.
    """
    
    @cache_on_self
    def store(self) -> Cache__Client__File__Store:
        """Routes__File__Store methods
        
        Store operations: store_json, store_bytes, store_file
        """
        return Cache__Client__File__Store(_cache_client=self._cache_client)
    
    @cache_on_self
    def retrieve(self) -> Cache__Client__File__Retrieve:
        """Routes__File__Retrieve methods
        
        Retrieve operations: retrieve_by_id, retrieve_by_hash
        """
        return Cache__Client__File__Retrieve(_cache_client=self._cache_client)
    
    @cache_on_self
    def delete(self) -> Cache__Client__File__Delete:
        """Routes__File__Delete methods
        
        Delete operations: delete_by_id, delete_namespace
        """
        return Cache__Client__File__Delete(_cache_client=self._cache_client)
    
    @cache_on_self
    def exists(self) -> Cache__Client__File__Exists:
        """Routes__File__Exists methods
        
        Existence checks: exists_by_id, exists_by_hash
        """
        return Cache__Client__File__Exists(_cache_client=self._cache_client)
```

**Individual Route Clients - Actual Operations**:

The leaf clients contain the actual methods that make requests. These use the exact same names as the service methods:

```python
class Cache__Client__File__Store:
    """Client for Routes__File__Store - uses same method names
    
    This client contains all the store operations for files. Each method
    corresponds exactly to a method in Routes__File__Store, with the same
    name, similar parameters, and equivalent functionality.
    """
    
    def store_json(self, data: dict, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_json()
        
        The parameters are Type_Safe validated, so we know:
        - data is a valid dictionary
        - namespace is a safe identifier (no path traversal)
        
        No validation needed here - Type_Safe ensures correctness.
        """
        path = f"/{namespace}/store/json"
        result = self.requests.execute("POST", path, data)
        
        # Only handle real errors, not validation
        if result.status_code == 404:
            raise Cache__Client__Error__Not_Found(f"Namespace {namespace} not found")
        elif result.status_code >= 500:
            raise Cache__Client__Error__Server("Server error")
            
        return Schema__Store__Response.from_json(result.json)
```

```python        
    def store_bytes(self, data: bytes, namespace: Safe_Str__Id = "default") -> Schema__Store__Response:
        """Exact same name as Routes__File__Store.store_bytes()
        
        Binary data storage with the same signature as the service method.
        """
        path = f"/{namespace}/store/bytes"
        result = self.requests.execute("POST", path, data)
        
        if result.status_code == 404:
            raise Cache__Client__Error__Not_Found(f"Namespace {namespace} not found")
        elif result.status_code >= 500:
            raise Cache__Client__Error__Server("Server error")
            
        return Schema__Store__Response.from_json(result.json)
```

**Usage Example - Natural Flow**:

The mirrored structure creates a natural, discoverable API:

```python
# Initialize client (mode is transparent)
client = Cache__Client(app=fast_api_app)  # Could be remote, in-memory, or local

# Natural navigation matching service structure
response = client.file().store().store_json({"key": "value"})

# Or for admin operations
status = client.admin().storage().get_status()

# The path matches the service organization exactly:
# Service: Routes__File__Store.store_json()
# Client:  client.file().store().store_json()
```

## Contract Extraction Using FastAPI Routes + OSBot AST

### Hybrid Extraction: FastAPI Runtime + AST Analysis

The contract extraction combines FastAPI's runtime route information (which knows the actual paths, HTTP methods, and parameters) with OSBot AST analysis (which can detect exception handling, return types, and internal logic). This hybrid approach gives us the best of both worlds:

```python
from fastapi import FastAPI
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

class Contract__Extractor(Type_Safe):
    
    def extract_contract(self, app: FastAPI) -> Schema__Service__Contract:
        """Extract contract from FastAPI app routes + AST analysis"""
        
        contract = Schema__Service__Contract(
            service_name=app.title,
            version=app.version
        )
        
        # Use FastAPI's actual route registry
        routes_by_module = self._organize_routes_by_module(app.routes)
        
        for module_name, routes in routes_by_module.items():
            module_contract = Schema__Routes__Module(
                module_name=module_name,
                route_classes=[],
                endpoints=[]
            )
            
            for route in routes:
                if not hasattr(route, 'endpoint'):
                    continue
                
                # Get actual runtime information from FastAPI
                endpoint_contract = self._extract_from_fastapi_route(route)
                
                # Enhance with AST analysis for internals
                self._enhance_with_ast_analysis(endpoint_contract, route.endpoint)
                
                module_contract.endpoints.append(endpoint_contract)
            
            contract.modules.append(module_contract)
            contract.endpoints.extend(module_contract.endpoints)
        
        return contract
    
        """Extract endpoint contract from FastAPI route object"""
        
        # Get actual path and method from FastAPI
        endpoint = Schema__Endpoint__Contract(
            path_pattern=route.path,                          # Real path like /{namespace}/{strategy}/store/json
            method=list(route.methods)[0] if route.methods else "GET",
            operation_id=route.endpoint.__name__,
            route_class=route.endpoint.__qualname__.split('.')[0] if '.' in route.endpoint.__qualname__ else None
        )
        
        # Extract path parameters from FastAPI route
        if hasattr(route, 'param_names'):
            for param_name in route.param_names:
                endpoint.path_params.append(Schema__Endpoint__Param(
                    name=param_name,
                    location='path',
                    param_type=self._get_param_type_from_signature(route.endpoint, param_name)
                ))
        
        # Extract query parameters from function signature
        import inspect
        sig = inspect.signature(route.endpoint)
        for param_name, param in sig.parameters.items():
            if param_name not in ['self', 'request'] and param_name not in route.param_names:
                endpoint.query_params.append(Schema__Endpoint__Param(
                    name=param_name,
                    location='query',
                    param_type=param.annotation if param.annotation != inspect.Parameter.empty else str,
                    required=param.default == inspect.Parameter.empty,
                    default=param.default if param.default != inspect.Parameter.empty else None
                ))
        
        return endpoint
```

```python        
    def _enhance_with_ast_analysis(self, endpoint: Schema__Endpoint__Contract, func):
        """Use AST to find things FastAPI doesn't know about"""
        
        # Parse the function with OSBot AST
        try:
            ast_module = Ast_Module(func)
            
            # Find actual exceptions raised (not validation errors)
            actual_errors = self._extract_actual_error_codes(ast_module)
            endpoint.expected_error_codes = actual_errors
            
            # Find return type if not obvious
            if not endpoint.response_schema:
                response_type = self._extract_return_type(ast_module)
                endpoint.response_schema = response_type
                
        except Exception:
            # If AST parsing fails, continue with FastAPI info only
            pass
```

```python        
    def _extract_actual_error_codes(self, func_ast: Ast_Module) -> List[int]:
        """Find which HTTPExceptions are actually raised (excluding validation)"""
        
        status_codes = []
        
        with Ast_Visit(func_ast) as visitor:
            visitor.capture('Ast_Raise')
            visitor.visit()
            
            for raise_node in visitor.captured_nodes()['Ast_Raise']:
                # Look for HTTPException with specific status codes
                if self._is_http_exception(raise_node):
                    status_code = self._extract_status_code(raise_node)
                    # Only include non-validation errors
                    if status_code not in [400, 422]:
                        status_codes.append(status_code)
        
        # Return unique status codes that matter
        return list(set(status_codes))
```

```python        
    def _organize_routes_by_module(self, routes) -> Dict[str, List]:
        """Organize FastAPI routes by module based on path structure"""
        
        routes_by_module = {}
        
        for route in routes:
            if not hasattr(route, 'path'):
                continue
                
            # Determine module from route class name
            if hasattr(route, 'endpoint') and hasattr(route.endpoint, '__qualname__'):
                class_name = route.endpoint.__qualname__.split('.')[0]
                
                # Extract module from class name (e.g., Routes__File__Store -> file)
                if class_name.startswith('Routes__'):
                    parts = class_name.replace('Routes__', '').split('__')
                    if len(parts) > 1:
                        module_name = parts[0].lower()  # e.g., 'file', 'admin', 'data'
                    else:
                        module_name = 'root'
                else:
                    module_name = 'root'
                
                if module_name not in routes_by_module:
                    routes_by_module[module_name] = []
                routes_by_module[module_name].append(route)
        
        return routes_by_module
```

### Contract Comparison with OSBot AST

The contract comparison process uses OSBot's structured data approach to detect changes:

```python
class Contract__Comparator(Type_Safe):
    
    def compare_with_ast_analysis(self, old: Schema__Service__Contract, 
                                  new: Schema__Service__Contract) -> Schema__Contract__Diff:
        """Compare contracts using OSBot AST's structured info() format"""
        
        diff = Schema__Contract__Diff()
        
        # Convert contracts to structured format using OSBot patterns
        old_info = self._contract_to_info(old)
        new_info = self._contract_to_info(new)
        
        # Use OSBot's json_data pattern for deep comparison
        changes = self._deep_compare_info(old_info, new_info)
        
        # Analyze changes for breaking modifications
        for change in changes:
            if self._is_breaking_change(change):
                diff.breaking_changes.append(change)
            else:
                diff.non_breaking_changes.append(change)
        
        return diff
```

```python        
    def _contract_to_info(self, contract: Schema__Service__Contract) -> Dict:
        """Convert contract to OSBot AST info() style format"""
        
        info = {
            'service_name': contract.service_name,
            'modules': {}
        }
        
        for module in contract.modules:
            module_info = {
                'route_classes': module.route_classes,
                'endpoints': {}
            }
            
            for endpoint in module.endpoints:
                endpoint_info = {
                    'method': endpoint.method,
                    'path': endpoint.path_pattern,
                    'params': {
                        'path': [p.name for p in endpoint.path_params],
                        'query': [p.name for p in endpoint.query_params]
                    }
                }
                module_info['endpoints'][endpoint.operation_id] = endpoint_info
            
            info['modules'][module.module_name] = module_info
        
        return info
```

## Error Handling Strategy

### Type_Safe Client-Side Validation Eliminates Server Validation Errors

A critical insight: with Type_Safe on both client and server, validation errors (400/422) **cannot happen** during normal operation. Type_Safe validates all data at assignment time on the client, before any network request is made:

```python
# These all fail CLIENT-SIDE, before any network request:

# Invalid GUID - fails immediately
cache_id = Random_Guid("not-a-guid")  # ValueError raised here!
client.file().retrieve(cache_id)      # Never reached, no network call

# Negative number for unsigned int - fails immediately  
age = Safe_UInt__Age(-5)              # ValueError: negative not allowed
client.user().update_age(age)         # Never reached, no network call

# Path traversal attempt - blocked by Safe_Str__Namespace
namespace = Safe_Str__Namespace("../../etc/passwd")  # ValueError raised here!
client.file().store(data, namespace)                 # Never reached, no network call

# Invalid enum value - fails immediately
strategy = Enum__Cache__Strategy("invalid")  # ValueError: not a valid strategy
client.store(data, strategy=strategy)        # Never reached, no network call
```

**This means our generated client code can be dramatically simplified:**

```python
def store_json(self, data        : dict                     ,
                     namespace   : Safe_Str__Namespace      ,
                     strategy    : Enum__Cache__Strategy    
               ) -> Schema__Store__Response:
    """
    No input validation needed - Type_Safe already validated everything!
    No 400/422 handling needed - impossible with valid Type_Safe objects!
    """
    
    path = f"/{namespace}/{strategy}/store/json"
    result = self.requests.execute("POST", path, data)
    
    # Only handle ACTUAL errors that can occur with valid data:
    if result.status_code == 404:
        # Resource genuinely doesn't exist
        raise Cache__Client__Error__Not_Found(f"Namespace {namespace} doesn't exist")
    
    elif result.status_code == 401:
        # Authentication issue
        raise Cache__Client__Error__Unauthorized("Invalid or missing API key")
    
    elif result.status_code == 409:
        # Business logic conflict (not validation)
        raise Cache__Client__Error__Conflict("Resource already exists")
    
    elif result.status_code >= 500:
        # Server error
        raise Cache__Client__Error__Server("Server error occurred")
    
    # Success - we know the response will be valid
    return Schema__Store__Response.from_json(result.json)
```

### Actual Errors vs Validation Errors

With Type_Safe validation on the client, we only need to handle **actual runtime errors**:

| Error Type | Status Code | When It Happens | Example |
|------------|-------------|-----------------|---------|
| **Validation** | 400/422 | **NEVER** - Type_Safe prevents this | Invalid GUID, negative age |
| **Not Found** | 404 | Resource doesn't exist | Namespace was deleted |
| **Unauthorized** | 401 | Auth failure | Invalid API key |
| **Forbidden** | 403 | Permission denied | User lacks access |
| **Conflict** | 409 | Business logic conflict | Duplicate key |
| **Gone** | 410 | Resource expired | Cache TTL expired |
| **Server Error** | 500+ | Server issues | Database down |
| **Network** | - | Connection issues | Timeout, DNS failure |

### Simplified Exception Hierarchy

Since we don't need validation error handling, our exception hierarchy is simpler:

```python
class Cache__Client__Error(Exception):
    """Base exception for cache client errors"""
    error_schema: Schema__Cache__Error
    
    def __init__(self, error_schema: Schema__Cache__Error):
        self.error_schema = error_schema
        super().__init__(str(error_schema.message))

# Only non-validation errors
class Cache__Client__Error__Not_Found(Cache__Client__Error):
    """404 - Resource doesn't exist"""
    pass

class Cache__Client__Error__Unauthorized(Cache__Client__Error):
    """401 - Authentication failed"""
    pass

class Cache__Client__Error__Forbidden(Cache__Client__Error):
    """403 - Permission denied"""
    pass

class Cache__Client__Error__Conflict(Cache__Client__Error):
    """409 - Business logic conflict"""
    pass

class Cache__Client__Error__Gone(Cache__Client__Error):
    """410 - Resource expired"""
    pass

class Cache__Client__Error__Server(Cache__Client__Error):
    """500+ - Server error"""
    pass

class Cache__Client__Error__Network(Cache__Client__Error):
    """Network/connection error"""
    pass
```

### Benefits of Type_Safe Client-Side Validation

This approach provides several critical benefits:

1. **Faster Failure**: Errors are caught immediately on the client, no network round-trip
2. **Better Error Messages**: Type_Safe knows exactly what's wrong with the data
3. **Zero Invalid Traffic**: No network bandwidth wasted on invalid requests
4. **Simpler Generated Code**: No need for complex validation error handling
5. **Smaller Client Library**: Less code to generate, ship, and maintain
6. **Guaranteed Server Protection**: Server never receives invalid data

### Error Handling in Generated Code

The AST generator creates minimal error handling since validation is already done:

```python
def _generate_error_handling_ast(self, endpoint: Schema__Endpoint__Contract) -> str:
    """Generate error handling for actual runtime errors only"""
    
    # Only handle errors that can occur with VALID data
    error_handlers = []
    
    # Get actual error codes from AST analysis (excluding 400/422)
    for status_code in endpoint.expected_error_codes:
        if status_code == 404:
            handler = '''
if response.status_code == 404:
    raise Cache__Client__Error__Not_Found(f"Resource not found: {path}")
'''
        elif status_code == 401:
            handler = '''
if response.status_code == 401:
    raise Cache__Client__Error__Unauthorized("Authentication failed")
'''
        elif status_code == 409:
            handler = '''
if response.status_code == 409:
    raise Cache__Client__Error__Conflict("Resource conflict")
'''
        else:
            continue  # Skip validation errors
        
        error_handlers.append(handler)
    
    # Add server error handler
    error_handlers.append('''
if response.status_code >= 500:
    raise Cache__Client__Error__Server(f"Server error: {response.status_code}")
''')
    
    return '\n'.join(error_handlers)
```

```python    
def _generate_endpoint_method_simplified(self, endpoint: Schema__Endpoint__Contract) -> str:
    """Generate simplified method with Type_Safe validation"""
    
    # Build the method template
    template = f'''
def {endpoint.route_method}(self{self._build_params_string(endpoint)}) -> {endpoint.response_schema.__name__}:
    """
    All parameters are Type_Safe validated before this method is called.
    No validation errors possible - Type_Safe ensures data is valid.
    """
    
    # Build path - we know all params are valid
    path = "{endpoint.path_pattern}".format(**locals())
    
    # Execute request - no validation needed
    response = self.requests.execute(
        method="{endpoint.method}",
        path=path,
        body=request if 'request' in locals() else None
    )
    
    # Only handle actual runtime errors
    {self._generate_error_handling_ast(endpoint)}
    
    # Success - deserialize response
    return {endpoint.response_schema.__name__}.from_json(response.json())
'''
    return template
```

### Contract Extraction Focuses on Actual Errors

The contract extractor now identifies only the errors that matter:

```python
def _extract_actual_error_codes(self, func_ast: Ast_Module) -> List[int]:
    """Extract only non-validation error codes from function"""
    
    actual_errors = []
    
    with Ast_Visit(func_ast) as visitor:
        visitor.capture('Ast_Raise')
        visitor.visit()
        
        for raise_node in visitor.captured_nodes()['Ast_Raise']:
            if self._is_http_exception(raise_node):
                status_code = self._extract_status_code(raise_node)
                
                # Skip validation errors - Type_Safe handles these
                if status_code not in [400, 422]:
                    actual_errors.append(status_code)
                    
                    # Log what kind of error this is
                    if status_code == 404:
                        self.log("Found: Resource not found error")
                    elif status_code == 401:
                        self.log("Found: Authentication error")
                    elif status_code == 409:
                        self.log("Found: Business logic conflict")
    
    return actual_errors
```

## Testing Strategy

### Test Structure Following Type_Safe and OSBot Patterns

Testing the generated clients is straightforward because of the three execution modes. The same test can run against in-memory (fast), local server (integration), or remote (end-to-end) modes. This flexibility, combined with Type_Safe validation, creates a robust testing strategy.

**Key Testing Principles**:

1. **Use `setUpClass` for expensive operations** - FastAPI app creation happens once per test class
2. **Leverage execution modes** - Unit tests use IN_MEMORY, integration tests use LOCAL_SERVER
3. **Trust Type_Safe validation** - Don't test validation that Type_Safe already handles
4. **Test behavior, not implementation** - Focus on what the client does, not how
5. **Use OSBot patterns** - Context managers, `__`, `__SKIP__` for dynamic values

Here's a comprehensive test suite that demonstrates all principles:

```python
from unittest import TestCase
from osbot_utils.testing.__ import __, __SKIP__

class test_Cache__Client(TestCase):
    
    @classmethod
    def setUpClass(cls):
        """Expensive setup once for all tests (OSBot pattern)
        
        Creating the FastAPI app is expensive. We do it once and reuse
        it for all tests in this class. This can speed up test suites
        by 10-100x compared to creating a new app for each test.
        """
        # Create service once
        cls.fast_api = Cache__Service__Fast_API()
        cls.fast_api.setup()
        cls.app = cls.fast_api.app()
```

```python        
    def test_transparent_modes(self):
        """Test that all three modes work transparently
        
        This test proves that the same client code works identically
        across all execution modes. This is the key value proposition
        of our architecture.
        """
        
        test_data = {"key": "value"}
        
        # Test remote mode (only if configured)
        # This allows tests to run in CI without a deployed service
        if os.getenv("CACHE_SERVICE_URL"):
            client_remote = Cache__Client(
                config=Cache__Client__Config(
                    target_server=os.getenv("CACHE_SERVICE_URL")
                )
            )
            result_remote = client_remote.file().store().store_json(test_data)
            assert isinstance(result_remote, Schema__Store__Response)
            assert result_remote.namespace == "default"
        
        # Test in-memory mode (fastest for unit tests)
        # This runs the entire request in-process, no HTTP overhead
        client_memory = Cache__Client(_app=self.app)
        result_memory = client_memory.file().store().store_json(test_data)
        assert isinstance(result_memory, Schema__Store__Response)
        assert result_memory.namespace == "default"
        
        # Test local server mode (real HTTP for integration tests)
        # This starts an actual HTTP server on localhost
        with Fast_API_Server(app=self.app) as server:
            client_local = Cache__Client(_server=server)
            result_local = client_local.file().store().store_json(test_data)
            assert isinstance(result_local, Schema__Store__Response)
            assert result_local.namespace == "default"
        
        # All three modes return the same type and behavior!
```

```python        
    def test_module_structure_mirrors_service(self):
        """Test that client structure matches service structure
        
        This test ensures our code generation correctly mirrors the
        service organization. If this test passes, we know navigation
        between service and client code will be intuitive.
        """
        
        with Cache__Client(app=self.app) as client:
            # Main modules exist
            assert hasattr(client, 'admin')
            assert hasattr(client, 'data')
            assert hasattr(client, 'file')
            assert hasattr(client, 'zip')
            
            # File sub-operations exist
            file_client = client.file()
            assert hasattr(file_client, 'store')
            assert hasattr(file_client, 'retrieve')
            assert hasattr(file_client, 'delete')
            assert hasattr(file_client, 'exists')
            
            # Methods match Routes__* methods exactly
            store_client = file_client.store()
            assert hasattr(store_client, 'store_json')
            assert hasattr(store_client, 'store_bytes')
            assert hasattr(store_client, 'store_file')
```

```python        
    def test_type_safe_validation_client_side(self):
        """Test that Type_Safe validation happens before network requests
        
        This test proves that invalid data never reaches the network.
        All validation happens at assignment time on the client.
        """
        
        with Cache__Client(app=self.app) as client:
            
            # Invalid GUID - fails before any network call
            with self.assertRaises(ValueError) as context:
                invalid_id = Random_Guid("not-a-guid")
                # The error happens above, this line is never reached
                client.file().retrieve(invalid_id)
            
            # The error message is from Type_Safe, not the server
            assert "Invalid GUID format" in str(context.exception)
            
            # Invalid namespace with path traversal - blocked by Safe_Str
            with self.assertRaises(ValueError) as context:
                bad_namespace = Safe_Str__Namespace("../../etc/passwd")
                client.file().store().store_json({}, namespace=bad_namespace)
            
            # Again, error is from Type_Safe on the client
            assert "Invalid characters" in str(context.exception)
```

```python        
    def test_only_real_errors_handled(self):
        """Test that only real runtime errors are handled, not validation
        
        Since Type_Safe handles validation, we only need to test real
        errors like resource not found, auth failures, etc.
        """
        
        with Cache__Client(app=self.app) as client:
            
            # Test 404 - Resource not found (real error)
            non_existent = Random_Guid()  # Valid GUID, but doesn't exist
            with self.assertRaises(Cache__Client__Error__Not_Found):
                client.file().retrieve(non_existent)
            
            # Test 401 - Auth failure (if auth is required)
            if client.config.requires_auth:
                client_no_auth = Cache__Client(app=self.app)
                client_no_auth.requests._auth_headers = {}  # Remove auth
                with self.assertRaises(Cache__Client__Error__Unauthorized):
                    client_no_auth.file().store().store_json({})
            
            # We DON'T test 400/422 because Type_Safe prevents them!
```

```python        
    def test_osbot_testing_patterns(self):
        """Demonstrate OSBot testing patterns with __ and __SKIP__
        
        These patterns make tests more readable and maintainable by
        clearly showing expected structure while skipping dynamic values.
        """
        
        with Cache__Client(app=self.app) as client:
            result = client.file().store().store_json({"test": "data"})
            
            # Use __ to show expected structure
            # Use __SKIP__ for dynamic values like IDs and timestamps
            assert result.obj() == __(
                cache_id   = __SKIP__,        # Dynamic ID
                cache_hash = __SKIP__,        # Dynamic hash
                namespace  = "default",       # Known value
                size       = 17,              # Known size
                created_at = __SKIP__,        # Dynamic timestamp
                ttl        = 3600             # Default TTL
            )
```

## CI/CD Integration

### Contract Validation Pipeline

The CI pipeline ensures contracts stay synchronized between service and client. This automation is crucial - without it, services and clients will inevitably drift apart. The pipeline detects changes, validates compatibility, and regenerates code automatically.

**Key Pipeline Components**:

1. **Contract Extraction** - Pull the current contract from the service
2. **Contract Comparison** - Detect changes from the stored contract
3. **Breaking Change Detection** - Identify changes that break compatibility
4. **Client Generation** - Regenerate client code if needed
5. **Test Validation** - Ensure generated code works correctly
6. **Version Management** - Update versions based on change severity

Here's the complete pipeline configuration with explanations:

```yaml
# .github/workflows/contract-validation.yml
name: Contract Validation

on:
  pull_request:
    paths:
      # Trigger when service routes change
      - 'mgraph_ai_service_cache/fast_api/routes/**'

jobs:
  validate_contract:
    runs-on: ubuntu-latest
    steps:
      - name: Extract Current Contract using OSBot AST
        # This step extracts the contract from the current service code
        # It uses FastAPI's route registry + AST analysis
        run: |
          python -m mgraph_ai_service_cache_client.contract.extract \
            --service-path ../mgraph_ai_service_cache \
            > contract_new.json
      
      - name: Compare Contracts using OSBot AST
        # Compare the new contract with the stored contract
        # This identifies what changed and whether it's breaking
        id: compare
        run: |
          python -m mgraph_ai_service_cache_client.contract.compare \
            contract/contract.json contract_new.json \
            --use-osbot-ast
          
          # Set outputs for later steps
          echo "::set-output name=changed::$(cat changed.txt)"
          echo "::set-output name=breaking::$(cat breaking.txt)"
      
      - name: Generate Client if Changed
        # If the contract changed, regenerate the client code
        # This ensures the client always matches the service
        if: steps.compare.outputs.changed == 'true'
        run: |
          python -m mgraph_ai_service_cache_client.contract.generate \
            --contract contract_new.json \
            --output client/ \
            --generator osbot-ast
      
      - name: Run Contract Tests with All Modes
        # Test the generated client in all three modes
        # This ensures the code works correctly
        run: |
          # Test in-memory mode (fastest, for unit tests)
          pytest tests/test_contract_compliance.py -m in_memory
          
          # Test local server mode (real HTTP, for integration)
          pytest tests/test_contract_compliance.py -m local_server
          
          # Test remote mode if configured (end-to-end)
          if [ -n "$CACHE_SERVICE_URL" ]; then
            pytest tests/test_contract_compliance.py -m remote
          fi
      
      - name: Version Bump Decision
        # Determine how to bump the version based on changes
        if: steps.compare.outputs.changed == 'true'
        run: |
          if [ "${{ steps.compare.outputs.breaking }}" == "true" ]; then
            echo "Breaking changes detected - major version bump needed"
            npm version major
          else
            echo "Non-breaking changes - minor version bump"
            npm version minor
          fi
      
      - name: Create PR with Updates
        # If on main branch, create a PR with the updates
        if: github.ref == 'refs/heads/main' && steps.compare.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v4
        with:
          title: "Update client for service contract changes"
          body: |
            ## Contract Changes Detected
            
            The service contract has changed. This PR updates the client code to match.
            
            Breaking: ${{ steps.compare.outputs.breaking }}
            
            Please review the generated code changes.
          branch: update-client-contract
```

### Automated Client Updates Using OSBot AST

The automation system detects contract changes and updates clients automatically. This removes the manual burden of keeping clients synchronized with services:

```python
class Client__Updater(Type_Safe):
    """Automated client updater using OSBot AST infrastructure
    
    This class orchestrates the entire update process:
    1. Extract current contract from service
    2. Compare with stored contract
    3. Generate new client if needed
    4. Run validation tests
    5. Update version numbers
    """
    
    service_path : Path           # Path to service code
    client_path  : Path           # Path to client code
    
    def update_if_needed(self) -> bool:
        """Check for contract changes and update client using OSBot AST
        
        Returns True if updates were made, False if no changes detected.
        This is the main entry point called by CI/CD pipelines.
        """
        
        # Step 1: Extract current contract from service
        # This uses FastAPI routes + AST analysis
        extractor = Contract__Extractor(service_path=self.service_path)
        current_contract = extractor.extract_contract()
        
        # Step 2: Load stored contract
        stored_contract = self.load_stored_contract()
        
        # Step 3: Compare contracts using OSBot AST
        comparator = Contract__Comparator()
        diff = comparator.compare_with_ast_analysis(stored_contract, current_contract)
        
        if not diff.has_changes():
            print("No contract changes detected")
            return False
        
        # Step 4: Log what changed (for PR descriptions)
        self.log_changes(diff)
        
        # Step 5: Generate new client code
        print(f"Generating client for {len(diff.all_changes())} changes...")
        generator = AST__Client__Generator(contract=current_contract)
        generated_files = generator.generate_client()
        
        # Step 6: Write generated files preserving structure
        for filepath, content in generated_files.items():
            self.write_file_preserving_structure(filepath, content)
        
        # Step 7: Update stored contract
        self.save_contract(current_contract)
        
        # Step 8: Run validation tests
        print("Running validation tests...")
        if not self.run_validation_tests():
            raise Exception("Generated client failed validation tests")
        
        # Step 9: Update version based on change severity
        if diff.has_breaking_changes():
            self.bump_major_version()
            print("Bumped major version due to breaking changes")
        else:
            self.bump_minor_version()
            print("Bumped minor version for non-breaking changes")
        
        return True
```

```python        
    def log_changes(self, diff: Schema__Contract__Diff):
        """Log changes for documentation and PR descriptions"""
        
        if diff.removed_endpoints:
            print(f"Removed endpoints: {diff.removed_endpoints}")
        
        if diff.added_endpoints:
            print(f"Added endpoints: {diff.added_endpoints}")
        
        if diff.modified_endpoints:
            print(f"Modified endpoints: {diff.modified_endpoints}")
        
        if diff.breaking_changes:
            print("⚠️  BREAKING CHANGES DETECTED")
            for change in diff.breaking_changes:
                print(f"  - {change}")
```

```python        
    def run_validation_tests(self) -> bool:
        """Run tests to validate the generated client
        
        Tests all three modes to ensure the client works correctly.
        """
        
        import subprocess
        
        # Test in-memory mode
        result = subprocess.run(
            ["pytest", "tests/test_generated_client.py", "-m", "in_memory"],
            capture_output=True
        )
        if result.returncode != 0:
            print("In-memory tests failed")
            return False
        
        # Test local server mode
        result = subprocess.run(
            ["pytest", "tests/test_generated_client.py", "-m", "local_server"],
            capture_output=True
        )
        if result.returncode != 0:
            print("Local server tests failed")
            return False
        
        print("All validation tests passed")
        return True
```

## Performance Optimizations

Performance is critical for client libraries - they're called frequently and any overhead multiplies across the application. Our approach combines several optimization strategies that work together to minimize latency and resource usage.

### Connection Pooling for Remote Mode

Network connections are expensive to establish. Creating a new connection for each request can add 10-100ms of overhead. Connection pooling reuses existing connections, dramatically improving performance:

```python
class Cache__Client__Requests__Remote__Optimized(Cache__Client__Requests):
    """Optimized remote request handling with connection pooling
    
    This class extends the base request handler with production-ready
    optimizations for remote HTTP calls. These optimizations can improve
    throughput by 10x and reduce latency by 50% or more.
    """
    
    def _configure_session(self):
        """Configure session with connection pooling and retry logic
        
        This method sets up a requests session optimized for production:
        - Connection pooling to reuse TCP connections
        - Automatic retries for transient failures
        - Sensible timeouts to prevent hanging
        - Keep-alive to maintain connections
        """
        
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        
        # Configure retry strategy for resilience
        # This handles transient network issues automatically
        retry = Retry(
            total=3,                                     # Total retry attempts
            backoff_factor=0.3,                         # Exponential backoff multiplier
            status_forcelist=[500, 502, 503, 504]       # Retry on server errors
        )
        
        # Configure connection pooling
        # These settings handle high concurrency efficiently
        adapter = HTTPAdapter(
            max_retries=retry,                          # Apply retry strategy
            pool_connections=10,                        # Number of connection pools
            pool_maxsize=20,                           # Connections per pool
            pool_block=False                            # Don't block when pool is full
        )
        
        # Apply adapter to both HTTP and HTTPS
        self._session.mount('http://', adapter)
        self._session.mount('https://', adapter)
        
        # Set default timeout to prevent hanging
        self._session.timeout = 30
        
        # Enable keep-alive for connection reuse
        self._session.headers.update({
            'Connection': 'keep-alive',
            'Keep-Alive': 'timeout=600, max=100'
        })
```

### Caching for Immutable Operations

Some operations always return the same result for the same input. Caching these results avoids unnecessary network calls and processing. OSBot's `@cache_on_self` decorator makes this trivial:

```python
class Cache__Client__File__Retrieve:
    """Retrieve operations with intelligent caching
    
    Hash-based retrievals are perfect for caching because:
    - Same hash always returns same content (immutable)
    - Hashes are unique identifiers
    - Content never changes for a given hash
    """
    
    @cache_on_self
    def retrieve_by_hash(self, cache_hash: Safe_Str__Hash) -> Schema__Cache__Item:
        """Cache results for immutable hash lookups
        
        This method is decorated with @cache_on_self, which means:
        - First call with a hash makes the network request
        - Subsequent calls with same hash return cached result
        - No network overhead for repeated retrievals
        - Cache is per-instance, so different clients don't interfere
        """
        # This only executes once per unique hash
        return self._retrieve_by_hash_impl(cache_hash)
```

```python        
    def _retrieve_by_hash_impl(self, cache_hash: Safe_Str__Hash) -> Schema__Cache__Item:
        """Actual implementation that makes the network call"""
        
        path = f"/retrieve/by-hash/{cache_hash}"
        result = self.requests.execute("GET", path)
        
        if result.status_code == 404:
            raise Cache__Client__Error__Not_Found(f"Hash {cache_hash} not found")
        elif result.status_code >= 500:
            raise Cache__Client__Error__Server("Server error")
            
        return Schema__Cache__Item.from_json(result.json)
```

```python        
    # Don't cache mutable operations
    def retrieve_latest(self, namespace: Safe_Str__Namespace) -> Schema__Cache__Item:
        """Retrieve latest item - NOT cached because it changes
        
        This method is intentionally not cached because:
        - "Latest" changes over time
        - We always want fresh data
        - Caching would return stale results
        """
        path = f"/{namespace}/retrieve/latest"
        result = self.requests.execute("GET", path)
        
        if result.status_code == 404:
            raise Cache__Client__Error__Not_Found(f"No items in {namespace}")
        elif result.status_code >= 500:
            raise Cache__Client__Error__Server("Server error")
            
        return Schema__Cache__Item.from_json(result.json)
```

### Key Performance Principles

1. **Cache Immutable Operations**: Use `@cache_on_self` for operations that always return the same result
2. **Pool Connections**: Reuse HTTP connections to avoid handshake overhead
3. **Validate Once**: Type_Safe validation happens on assignment - reuse validated objects
4. **Batch When Possible**: Reduce network round-trips by batching operations
5. **Lazy Loading**: Use `@cache_on_self` for module initialization
6. **Monitor Performance**: Measure to ensure optimizations are working
7. **Consider Async**: For high-concurrency scenarios, async clients provide better throughput

## Implementation Checklist

- [ ] **OSBot AST Integration** - Extend OSBot AST classes for client generation
- [ ] **Contract Schema** - Define Type_Safe contract schemas with route structure
- [ ] **Contract Extraction** - Use Ast_Visit to extract from Routes__* classes  
- [ ] **AST Generator** - Build generator using Ast_Module, Ast_Merge, Ast_Function_Def
- [ ] **Transparent Modes** - Implement Cache__Client__Requests with three modes
- [ ] **Module Structure** - Generate client structure mirroring service routes
- [ ] **Method Naming** - Use exact same method names as Routes__* classes
- [ ] **Error Handling** - Create typed exception hierarchy with Type_Safe schemas
- [ ] **Generated Code** - Generate initial client from contract using OSBot AST
- [ ] **Tests** - Write tests for all three transparent modes
- [ ] **CI Pipeline** - Set up contract validation with OSBot AST tools
- [ ] **Documentation** - Generate client docs from OSBot AST info() data
- [ ] **Performance** - Add connection pooling and @cache_on_self
- [ ] **Versioning** - Implement semantic versioning based on AST diff analysis

## Summary

This implementation guide provides a complete blueprint for building contract-driven FastAPI clients that leverage both FastAPI's runtime route information and OSBot-Utils AST infrastructure:

1. **Hybrid Contract Extraction**: Use FastAPI's actual route objects for paths/methods + OSBot AST for internal analysis
2. **Type_Safe Validation Eliminates Server Errors**: Client-side validation means 400/422 errors are impossible
3. **OSBot AST classes** provide clean abstractions over raw Python AST
4. **Three transparent execution modes** via unified request handling
5. **Exact service structure mirroring** with Routes__* → Cache__Client__* mapping
6. **Same method names** preserved from service to client
7. **Simplified error handling** - only handle actual runtime errors (404, 401, 409, 500+)
8. **Clean code generation** with Ast_Merge and structured node manipulation
9. **Faster failure** - validation errors caught client-side, no network round-trip
10. **Smaller, simpler clients** - no validation error handling code needed

The critical insight is that **Type_Safe on the client makes validation errors impossible**, dramatically simplifying the generated client code. Combined with FastAPI's runtime route information, we get perfect contract extraction without guessing, and cleaner clients that fail fast and provide better error messages.

The approach eliminates manual client maintenance while providing:
- **Zero invalid network traffic** - Type_Safe blocks bad data before requests
- **Immediate validation feedback** - No waiting for server round-trips
- **Simpler generated code** - No 400/422 error handling needed
- **Perfect route accuracy** - Using FastAPI's actual routes, not guessing from names
- **Complete type safety** - Through the entire request/response lifecycle