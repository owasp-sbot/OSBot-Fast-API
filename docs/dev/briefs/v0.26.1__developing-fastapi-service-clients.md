# Developing FastAPI Service Clients (Dual Contract Implementation)

*by Dinis Cruz and ChatGPT Deep Research, 27th September 2025, v0.27.0*

## Introduction

In a previous article, we introduced a **dual-layer API contract**
pattern, where each service exposes a low-level REST API and a stable
high-level Python client API. We now focus on **how to implement the
Python client layer** for FastAPI services using this pattern. The goal
is to create client libraries that are easy to use **and** easy to
maintain as the service evolves. We will use the example of a Cache
Service (built with FastAPI and [OSBot-Fast-API
extensions][^osbot-fastapi]) and outline how to design its client
SDK. This brief covers the architectural approach, project structure,
example code, and CI/CD automation to keep the client and server in
sync.

**Key Objectives for the Client SDK:**
- Provide a **clean, Pythonic API** for service consumers (hiding HTTP
details).
- Ensure **type-safe** interactions end-to-end by sharing data schema
classes between server and client.
- Maintain **easy synchronization** with the service's REST API
(minimize manual updates when endpoints change).
- Support three **execution modes**: **remote calls** (to a deployed service), 
**in-memory calls** (using FastAPI's TestClient), and **local server** (using Fast_API_Server for testing).
- Leverage **auto-generation** or conventions to reduce boilerplate in
client code, while preserving IDE friendliness (actual methods for
auto-complete).
- Integrate into CI/CD pipelines so that any contract changes in the
service trigger updates or tests in the client library.

## Architecture of the Client Library

The client library serves as a high-level interface to the service. It
internally knows how to call the REST endpoints but presents developers
with simple function calls and Python objects. Here's the architecture
and design principles:

-   **Client-Owned Schemas:** All request/response data models (schemas) are
    defined as **Type_Safe** classes in the client package. The FastAPI 
    service depends on the client package (installed via PyPI) and imports 
    these classes, ensuring a single source of truth for data structures. 
    This approach enables the client to operate in a **standalone mode** 
    with no server dependencies while allowing the server to be **pinned to 
    a specific client version**. Using OSBot's **Type_Safe** framework means 
    that these classes enforce type rules at runtime and seamlessly convert 
    to/from JSON when used in FastAPI. The server imports from
    `mgraph_ai_cache_client.schemas` when declaring request/response types.
    By doing so, we guarantee the server and client use identical models.

-   **Client Class and Methods:** The client library provides a class
    (e.g. `CacheClient`) with methods for each major operation of the
    service. Each method has a **friendly name** and signature, hiding
    the REST specifics. For example, instead of making the user issue an
    HTTP POST to `/{namespace}/{strategy}/store/json`, the client might
    offer a method
    `store_json(data, strategy="default", namespace="default")` that
    internally performs the POST. The method will accept native Python
    types or Type_Safe objects as input and will return Python objects
    (often Type_Safe instances or plain primitives) as output. Under the 
    hood, the client method constructs the proper URL path, sends the 
    request, and parses the response.

-   **Routing Conventions:** Our FastAPI service uses a consistent
    naming convention for routes and path parameters (facilitated by
    OSBot-Fast-API). For instance, a route function named
    `get_user__id()` automatically becomes an endpoint
    `/get-user/{id}`[[2]](https://pypi.org/project/osbot-fast-api/#:~:text=Route%20Path%20Generation).
    Similarly, `store_json` might correspond to a route path like
    `/cache/store/json`. The client can leverage these conventions. The
    key is that the client "knows" the correct endpoint URL pattern for
    each operation. We ensure the mapping between client method and
    server endpoint is unambiguous, either through naming convention or
    a lookup table generated from the server's OpenAPI spec.

-   **Three Execution Modes:** The client is designed
    to operate in three modes:

    -   **Remote mode** -- Calls are sent over HTTP to a running service
      (e.g. at `http://localhost:8000` or a production URL). This is the
      normal usage when the service is deployed.

    -   **In-memory mode** -- Calls are directed to an in-process FastAPI app
        for testing. FastAPI's `TestClient` (or OSBot-Fast-API's
        `Fast_API_Server`) can simulate HTTP calls without network
        overhead[[3]](https://pypi.org/project/osbot-fast-api/#:~:text=from%20osbot_fast_api).
        In this mode, the client is instantiated with a reference to the
        FastAPI app instead of a base URL, and it uses the TestClient to
        execute requests directly. The result is the same -- the service's
        logic runs -- but it all happens within one process.
        
    -   **Local server mode** -- A `Fast_API_Server` instance is started
        locally for integration testing. This provides a real HTTP server
        running on localhost but managed by the test framework. The client
        is instantiated with the local server's URL. This mode is useful
        for testing HTTP-specific behaviors while maintaining test isolation.

-   **Type Safety and Conversion:** Because we share Type_Safe schemas,
    the client can provide comprehensive runtime guarantees. Type_Safe's
    continuous validation ensures that even collection operations are
    type-checked. For JSON serialization and deserialization, Type_Safe
    provides dedicated methods: `.json()` to serialize to a dictionary,
    and `.from_json()` to reconstruct a Type_Safe object from JSON data.
    This ensures perfect round-trip serialization where all types, including
    enums and nested Type_Safe objects, are preserved. The client will use
    `SchemaClass.from_json(response_json)` to convert API responses back
    to Type_Safe objects, maintaining full type safety throughout.

-   **Backward Compatibility:** The client library is the stable
    interface, so we aim to keep its methods backward-compatible. If the
    service changes an endpoint or schema, we update the client under
    the hood while preserving the method signature whenever possible. 
    Because both client and server are in active development together
    (often by the same team), such changes are coordinated. The dual 
    contract approach gives us flexibility: the REST API can change, 
    but the client adapts to keep external usage consistent.

## Project Structure and Schema Sharing

We will maintain **separate repositories** (or at least separate Python
packages) for the service and its client library. For example, for the
Cache service:

-   **Service Repository** (e.g. `MGraph-AI__Service__Cache`): Contains
    the FastAPI service implementation. This includes the route classes,
    internal logic, and any persistence or caching mechanism. Notably,
    this repo **does not define its own schemas**; instead, it depends
    on the client package for the schema definitions. This means in the
    FastAPI route functions, we import classes from
    `mgraph_ai_cache_client.schemas` when declaring
    request/response types. By doing so, we guarantee the server and
    client use identical models. The service is pinned to a specific
    version of the client package in its requirements.

-   **Client Repository** (e.g. `MGraph-AI__Service__Cache__Client`,
    Python package name `mgraph_ai_cache_client`): Contains the schema
    definitions and the client code. This package is versioned and can
    be published to PyPI for others to use. The layout might look like:

```
    mgraph_ai_cache_client/  
    ├── pyproject.toml  (or setup.py)  
    ├── README.md  
    ├── mgraph_ai_cache_client/  
    │   ├── __init__.py  
    │   ├── schemas/  
    │   │   ├── __init__.py  
    │   │   └── cache_models.py   # e.g., classes Schema__Cache__Store_Request, Schema__Cache__Item, etc.  
    │   ├── client.py        # Main client class (CacheClient)  
    │   ├── _endpoints.py    # (Optional) auto-generated low-level endpoint mapping/functions  
    │   └── utils.py         # (Optional) utilities (e.g., for local mode or auth)  
    └── tests/  
        ├── test_client_remote.py   # tests using an actual running server or mock server  
        ├── test_client_local.py    # tests using in-memory FastAPI app  
        └── test_client_server.py   # tests using Fast_API_Server
```

In this structure, `cache_models.py` would define classes like
`CacheItem`, `CacheStoreRequest`, `CacheStoreResponse`, etc., all
subclassing `Type_Safe`. The `client.py` would define `CacheClient` with
high-level methods. Optionally, `_endpoints.py` could be a module
generated from the service's OpenAPI spec, containing a mapping of each
operation (with its URL path, HTTP method, and associated schema
classes). 

**Shared Schema Example:** If `CacheItem` is a Type_Safe class with
fields like `id: Safe_Id`, `data: dict`, etc., it will live in the
client's `schemas` module. The FastAPI server might have a route
function like:

```python
    # In service code
    from mgraph_ai_cache_client.schemas.cache_models import CacheItem, CacheStoreRequest

    class Routes_Cache(Fast_API__Routes):
        tag = "cache"

        def store_json(self, request: CacheStoreRequest) -> CacheItem:
            # ... (store logic) ...
            return CacheItem(id=stored_id, data=request.data)
        
        def get_item__id(self, id: Safe_Id) -> CacheItem:
            # ... retrieve item by id ...
            return CacheItem(id=id, data=...)
        
        def setup_routes(self):
            self.add_route_post(self.store_json)       # POST /cache/store-json
            self.add_route_get(self.get_item__id)      # GET /cache/get-item/{id}
```

In the above, the schemas `CacheStoreRequest` and `CacheItem` come from
the client package. The naming `get_item__id` will produce a path with
`{id}` as a path
param[[2]](https://pypi.org/project/osbot-fast-api/#:~:text=Route%20Path%20Generation).
The OpenAPI spec is generated from this and will also reference the
schema classes (via their definitions).

On the client side, we mirror these operations:

```python
    # In client.py
    from .schemas import cache_models
    from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server

    class CacheClient:
        def __init__(self, base_url: str = "http://localhost:8000", app=None, server=None):
            self.mode = None
            self._base_url = base_url
            self._app = app
            self._server = server
            self._client = None
            
            if app:
                # In-memory mode using TestClient
                from fastapi.testclient import TestClient
                self._client = TestClient(app)
                self.mode = "in_memory"
            elif server:
                # Local server mode
                if not isinstance(server, Fast_API_Server):
                    server = Fast_API_Server(app=server)
                self._server = server
                self._base_url = server.base_url()
                self.mode = "local_server"
            else:
                # Remote mode
                self.mode = "remote"

        def store_json(self, data: dict, strategy: str = "default", namespace: str = "default") -> cache_models.CacheItem:
            """Store a JSON payload in the cache and return a CacheItem handle."""
            url = f"/{namespace}/{strategy}/store/json"
            
            if self.mode == "in_memory":
                response = self._client.post(url, json=data)
            elif self.mode in ["remote", "local_server"]:
                import requests
                response = requests.post(f"{self._base_url}{url}", json=data)
                
            response.raise_for_status()
            # Use Type_Safe's from_json method for proper deserialization
            return cache_models.CacheItem.from_json(response.json())
```

The above snippet illustrates the three-mode implementation. In
`store_json`, we build the URL using the namespace/strategy parameters.
Depending on the mode, we use either TestClient (in-memory), or 
requests (remote/local_server). After getting the JSON response, we 
create a `CacheItem` object using Type_Safe's `from_json()` method. 
This ensures proper type validation and conversion, including any 
nested Type_Safe objects, enums, or Safe primitive types. The caller 
receives a fully-typed `CacheItem` instance ready to use.

**Handling Path and Query Parameters:** For methods that retrieve or 
delete items by ID, the client method would accept an `id` argument 
(ideally typed as `Safe_Id` or appropriate Safe type) and include it 
in the URL path. For query parameters, we can build on Type_Safe's 
ability to serialize to dictionaries:

```python
        def get_item(self, item_id: Safe_Id, namespace: Safe_Str__Namespace = None) -> cache_models.CacheItem:
            """Retrieve a cached item by its ID."""
            namespace = namespace or Safe_Str__Namespace("default")
            url = f"/{namespace}/retrieve/{item_id}"
            
            if self.mode == "in_memory":
                response = self._client.get(url)
            else:
                import requests
                response = requests.get(f"{self._base_url}{url}")
                
            response.raise_for_status()
            return cache_models.CacheItem.from_json(response.json())
            
        def search_items(self, query_params: cache_models.SearchParams) -> List[cache_models.CacheItem]:
            """Search items with query parameters."""
            # Type_Safe objects can serialize to dict for query params
            params = query_params.json()  # Returns dict suitable for requests
            
            if self.mode == "in_memory":
                response = self._client.get("/search", params=params)
            else:
                import requests
                response = requests.get(f"{self._base_url}/search", params=params)
                
            response.raise_for_status()
            # Deserialize list of items
            items_json = response.json()
            return [cache_models.CacheItem.from_json(item) for item in items_json]
```

## Leveraging Type_Safe Features

Type_Safe provides several powerful features that make client 
development more robust:

### Auto-initialization and Collections

Type_Safe automatically initializes collections as Type_Safe variants
(`Type_Safe__List`, `Type_Safe__Dict`), which provide continuous 
runtime type checking. This means the client can trust that data 
structures maintain their type constraints throughout their lifecycle:

```python
    from osbot_utils.type_safe.Type_Safe import Type_Safe
    from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id
    from typing import List, Dict

    class CacheMetadata(Type_Safe):
        tags: List[Safe_Str__Tag]           # Auto-initializes to Type_Safe__List
        attributes: Dict[str, str]           # Auto-initializes to Type_Safe__Dict
        references: List[Safe_Id]            # Each element validated as Safe_Id
```

### Safe Primitives for API Parameters

Instead of raw strings and integers, use domain-specific Safe types
for API parameters. This provides automatic validation and sanitization:

```python
    from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Namespace import Safe_Str__Namespace
    from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key import Safe_Str__Key
    from osbot_utils.type_safe.primitives.core.Safe_UInt import Safe_UInt

    class CacheClient:
        def store_with_ttl(self, 
                          data: dict,
                          key: Safe_Str__Key,
                          namespace: Safe_Str__Namespace,
                          ttl_hours: Safe_UInt) -> CacheItem:
            # Safe types ensure valid values before making API call
            # Safe_Str__Namespace allows dots for hierarchical namespaces
            # Safe_Str__Key allows dots for nested keys
            # Safe_UInt ensures non-negative integer
            pass
```

### Enum and Literal Support

Type_Safe fully supports Python enums and Literal types with automatic
serialization/deserialization:

```python
    from enum import Enum
    from typing import Literal

    class CacheStrategy(str, Enum):
        DIRECT = "direct"
        TEMPORAL = "temporal"
        TEMPORAL_LATEST = "temporal_latest"
        SEMANTIC_FILE = "semantic_file"

    class CacheRequest(Type_Safe):
        strategy: CacheStrategy = CacheStrategy.TEMPORAL_LATEST
        priority: Literal["low", "normal", "high"] = "normal"
        
    # Client method can accept enum or string
    def store(self, data: dict, strategy: Union[CacheStrategy, str]) -> CacheItem:
        request = CacheRequest(strategy=strategy)  # Auto-converts string to enum
        # request.json() serializes enum to string for API
        # CacheRequest.from_json() restores enum from string
```

### Perfect Round-Trip Serialization

Type_Safe guarantees that data survives JSON round-trips with all
type information preserved:

```python
    # Complex nested structure with enums and Safe types
    original = CacheRequest(
        strategy=CacheStrategy.SEMANTIC_FILE,
        priority="high",
        metadata=CacheMetadata(tags=["important", "archive"])
    )
    
    # Serialize for API
    json_data = original.json()  # Dict with string representations
    
    # Send to API, get response...
    
    # Reconstruct with full type preservation
    restored = CacheRequest.from_json(json_data)
    assert restored.strategy == CacheStrategy.SEMANTIC_FILE  # Enum restored
    assert isinstance(restored.metadata.tags, Type_Safe__List)  # Collection type preserved
```

## Automating Client Code Generation

To minimize manual work and ensure consistency, we should automate as
much of the client code creation as possible. There are a few strategies
to consider:

-   **OpenAPI-driven generation:** FastAPI produces an OpenAPI JSON
    schema for the service, which includes all endpoints, their methods,
    paths, and request/response models. We can leverage this to generate
    client code. For example, a script can load the OpenAPI spec
    (available at runtime via `fast_api.app().openapi()`) and iterate
    over the paths. For each operation, it can determine the Python
    method name (perhaps based on the operationId or the endpoint path)
    and the expected request/response schema classes. Since our schema
    classes are Type_Safe classes in the client package, the generator
    can map OpenAPI component references to actual Type_Safe class 
    names. The Type_Safe schemas in the OpenAPI spec maintain their
    full type information, allowing accurate code generation.

-   **Introspection of Type_Safe classes:** Type_Safe provides extensive
    introspection capabilities through methods like `__attr_names__()`,
    `__kwargs__()`, and `__cls_kwargs__()`. We can use these to understand
    the structure of request/response classes and generate appropriate
    client methods. For instance, we could inspect which attributes are
    required vs optional, what their Safe types are, and generate method
    signatures accordingly.

-   **Static vs Dynamic:** We prefer **static generation** of code to
    ensure that developers get autocompletion and to keep the client
    code explicit. The generation script can be re-run whenever the API 
    changes, producing actual Python methods with proper type hints.

**Example Auto-Generation Workflow:** We might include a CLI command or
script in the client repo (for example, `generate_client.py`). This
script could:

1.  Spin up the FastAPI app from the service (possibly by importing the
    app object or running the app in a thread).
2.  Retrieve the OpenAPI JSON (e.g., by calling the app's `.openapi()`
    method).
3.  Parse the JSON to find all operations. For each operation, determine
    a suitable Python method name based on the endpoint path pattern.
4.  Identify the Type_Safe request/response schemas by their names in
    the OpenAPI components. Map these to the actual Type_Safe classes
    in the client's schemas module.
5.  Generate method definitions with proper type hints, using Type_Safe's
    `.from_json()` for response deserialization and `.json()` for request
    serialization.

This automation ensures that when the service interface changes, the 
client can be updated with minimal effort while maintaining full 
Type_Safe type safety.

## CI/CD: Keeping Client and Server in Sync

To successfully implement the dual contract pattern, it's crucial to
keep the client library synchronized with the service API. We can
achieve this with a combination of continuous integration checks and
automation:

-   **Shared Tests:** One effective technique is to **test the service
    using the client library**. In the service repository's test suite,
    include the client package (install it from source or as a dev
    dependency). Write integration tests that start the FastAPI app
    (perhaps with `Fast_API_Server` or TestClient) and then call client
    methods. For example, following the Type_Safe testing patterns:

```python
    from osbot_utils.testing.__ import __
    from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server
    from mgraph_ai_cache_client import CacheClient, schemas
    from unittest import TestCase
    
    class test_integration(TestCase):
        @classmethod
        def setUpClass(cls):  # Use setUpClass for expensive setup
            cls.fast_api = Fast_API()
            cls.fast_api.setup()
            cls.fast_api.add_routes(Routes_Cache)
            cls.app = cls.fast_api.app()
            
        def test_store_and_retrieve(self):
            with CacheClient(app=self.app) as client:  # Context manager pattern
                data = {"foo": "bar"}
                result = client.store_json(data)
                
                # Use Type_Safe testing patterns
                assert type(result) is schemas.CacheItem
                assert result.obj() == __(
                    id=result.id,  # Use __SKIP__ for dynamic values if needed
                    data=data,
                    namespace="default"
                )
                
                # Now retrieve it
                fetched = client.get_item(result.id)
                assert fetched.data == data
```

This kind of test, run in the service's CI, serves two purposes: it
verifies the service functionality end-to-end, and it instantly reveals
if the client is out-of-sync with the service. If the service changed
an endpoint or response format and the client wasn't updated, these 
tests would fail.

-   **OpenAPI Snapshot Comparison:** Another CI strategy is to treat the
    OpenAPI spec as a contract artifact. We can store a *snapshot* of
    the service's OpenAPI JSON in the client repository. Whenever the 
    service code changes, we generate the new OpenAPI and compare it to
    the snapshot. If there are changes, that indicates a contract update
    requiring client regeneration.

-   **CI for Client Repo:** The client library itself will have its own
    CI pipeline. Following Type_Safe testing best practices, tests should
    use `setUpClass` for expensive operations like setting up the FastAPI
    app, and use the context manager pattern with `_` for Type_Safe objects.

-   **Automatic Release Process:** Upon merging a change to the service's 
    main branch that affects the API, one could have a pipeline job that 
    updates the client code, bumps the client package version, and pushes 
    a new release to PyPI. The service can then update its dependency to
    the new client version.

-   **Versioning Strategy:** We will use semantic versioning for the
    client library. The CI can enforce that if a snapshot diff indicates 
    a breaking change, the client version must be incremented appropriately.

## Testing Modes Example

Here's a complete example showing all three testing modes for the client:

```python
from unittest import TestCase
from osbot_utils.testing.__ import __, __SKIP__
from osbot_fast_api.utils.Fast_API_Server import Fast_API_Server

class test_CacheClient(TestCase):
    
    def test_remote_mode(self):
        """Test against actual deployed service"""
        if not os.getenv("CACHE_SERVICE_URL"):
            self.skipTest("Remote service not configured")
            
        with CacheClient(base_url=os.getenv("CACHE_SERVICE_URL")) as client:
            result = client.store_json({"test": "data"})
            assert result.obj().contains(__(data={"test": "data"}))
    
    def test_in_memory_mode(self):
        """Test with in-process FastAPI app"""
        # Create FastAPI app
        fast_api = Fast_API()
        fast_api.setup()
        fast_api.add_routes(Routes_Cache)
        
        with CacheClient(app=fast_api.app()) as client:
            result = client.store_json({"test": "data"})
            assert result.obj() == __(
                id=__SKIP__,  # Dynamic ID
                data={"test": "data"},
                namespace="default"
            )
    
    def test_local_server_mode(self):
        """Test with local HTTP server"""
        fast_api = Fast_API()
        fast_api.setup()
        fast_api.add_routes(Routes_Cache)
        
        with Fast_API_Server(app=fast_api.app()) as server:
            with CacheClient(server=server) as client:
                # Tests actual HTTP communication
                result = client.store_json({"test": "data"})
                assert result.obj().contains(__(data={"test": "data"}))
```

## Summary

This dual contract implementation leverages Type_Safe's powerful 
features to create robust, type-safe client libraries for FastAPI 
services. Key aspects include:

- **Client-owned schemas** ensure consistency while maintaining independence
- **Type_Safe's runtime validation** provides safety at every operation
- **Three execution modes** enable flexible testing and deployment
- **Perfect serialization** through `.json()` and `.from_json()` methods
- **Safe primitives and enums** provide domain-specific validation
- **Automated code generation** keeps client and server synchronized
- **CI/CD integration** ensures contract changes are detected immediately

By following these patterns, we create client libraries that are both
developer-friendly and maintainable, while preserving all the type
safety guarantees that Type_Safe provides.

[^osbot-fastapi]: OSBot-Fast-API provides Type_Safe integration and routing conventions for FastAPI