# Developing FastAPI Service Clients (Dual Contract Implementation)

*by Dinis Cruz and ChatGPT Deep Research, 27th September 2025, v0.26.1*

## Introduction

In a previous article, we introduced a **dual-layer API contract**
pattern, where each service exposes a low-level REST API and a stable
high-level Python client API. We now focus on **how to implement the
Python client layer** for FastAPI services using this pattern. The goal
is to create client libraries that are easy to use **and** easy to
maintain as the service evolves. We will use the example of a Cache
Service (built with [FastAPI and OSBot-Fast-API
extensions][^osbot-fastapi]) and outline how to design its client
SDK. This brief covers the architectural approach, project structure,
example code, and CI/CD automation to keep the client and server in
sync.

**Key Objectives for the Client SDK:**
- Provide a **clean, Pythonic API** for service consumers (hiding HTTP
details).
- Ensure **type-safe** interactions end-to-end by sharing data schema
classes between server and client.
- Maintain **easy synchronization** with the service's REST API
(minimize manual updates when endpoints change).
- Support both **remote calls** (to a deployed service) and **in-memory
calls** (using FastAPI's TestClient) for testing or local usage.
- Leverage **auto-generation** or conventions to reduce boilerplate in
client code, while preserving IDE friendliness (actual methods for
auto-complete).
- Integrate into CI/CD pipelines so that any contract changes in the
service trigger updates or tests in the client library.

## Architecture of the Client Library

The client library serves as a high-level interface to the service. It
internally knows how to call the REST endpoints but presents developers
with simple function calls and Python objects. Here's the architecture
and design principles:

-   **Shared Schemas:** All request/response data models (schemas) are
    defined as **Type_Safe** classes in a shared location (the client
    package). The FastAPI service and the client both import these
    classes, ensuring a single source of truth for data structures. For
    example, a `CacheEntry` schema class (perhaps
    `Schema__Cache__Entry`) would be used by the server (in FastAPI
    route functions) and also by the client (for return values). This
    avoids any JSON schema duplication or drift between client and
    server. Using OSBot's **Type_Safe** framework means that these
    classes enforce type rules at runtime and seamlessly convert to/from
    JSON when used in
    FastAPI[[1]](https://pypi.org/project/osbot-fast-api/#:~:text=def%20create_person%28self%2C%20person%3A%20Person%29%3A%20,Automatically%20converted%20back%20to%20JSON).
    In practice, FastAPI (with OSBot-Fast-API) will automatically
    convert a Type_Safe object returned by a route into JSON for the
    HTTP
    response[[1]](https://pypi.org/project/osbot-fast-api/#:~:text=def%20create_person%28self%2C%20person%3A%20Person%29%3A%20,Automatically%20converted%20back%20to%20JSON).
    Conversely, the client can take JSON from a response and instantiate
    the corresponding Type_Safe class to get a fully validated Python
    object.

-   **Client Class and Methods:** The client library provides a class
    (e.g. `CacheClient`) with methods for each major operation of the
    service. Each method has a **friendly name** and signature, hiding
    the REST specifics. For example, instead of making the user issue an
    HTTP POST to `/{namespace}/{strategy}/store/json`, the client might
    offer a method
    `store_json(data, strategy="default", namespace="default")` that
    internally performs the POST. The method will accept native Python
    types or Type_Safe objects as input and will return Python objects
    (often Type_Safe instances or plain primitives) as output. This way,
    a developer can call `client.store_json({...})` and get back a
    `CacheResult` object, without manually dealing with `requests` or
    `httpx`. Under the hood, the client method constructs the proper URL
    path, sends the request, and parses the response.

-   **Routing Conventions:** Our FastAPI service uses a consistent
    naming convention for routes and path parameters (facilitated by
    OSBot-Fast-API). For instance, a route function named
    `get_user__id()` automatically becomes an endpoint
    `/get-user/{id}`[[2]](https://pypi.org/project/osbot-fast-api/#:~:text=Route%20Path%20Generation).
    Similarly, `store_json` might correspond to a route path like
    `/cache/store/json`. The client can leverage these conventions. In
    many cases, the client method name can mirror the server function
    name (sans special characters) or be a more user-friendly alias. The
    key is that the client "knows" the correct endpoint URL pattern for
    each operation. We ensure the mapping between client method and
    server endpoint is unambiguous, either through naming convention or
    a lookup table generated from the server's OpenAPI spec.

-   **Two Execution Modes (Remote vs. Local):** The client is designed
    to operate in two modes:

-   **Remote mode** -- Calls are sent over HTTP to a running service
    (e.g. at `http://localhost:8000` or a production URL). This is the
    normal usage when the service is deployed.

-   **Local mode** -- Calls are directed to an in-process FastAPI app
    for testing. FastAPI's `TestClient` (or OSBot-Fast-API's
    `Fast_API_Server`) can simulate HTTP calls without network
    overhead[[3]](https://pypi.org/project/osbot-fast-api/#:~:text=from%20osbot_fast_api).
    In this mode, the client is instantiated with a reference to the
    FastAPI app instead of a base URL, and it uses the TestClient to
    execute requests directly. The result is the same -- the service's
    logic runs -- but it all happens within one process. This is
    extremely useful for integration tests and for using the service
    logic in offline scenarios. The client class will abstract this
    difference so that from the caller's perspective,
    `client.store_json(data)` works the same in local or remote mode.

-   **Type Safety and Conversion:** Because we share Type_Safe schemas,
    the client can provide additional guarantees. For example, if a
    client method returns a `CacheEntry`, it can either return it as a
    constructed `Schema__Cache__Entry` object or at least validate the
    response JSON against that schema. Type_Safe primitives (like safe
    strings, safe int, etc.) ensure that even basic data is validated
    (e.g., an `Email` class that only accepts strings with
    "@")[[4]](https://pypi.org/project/osbot-fast-api/#:~:text=Type).
    On the input side, the client could accept either a raw Python dict
    or a Type_Safe object -- if a dict is provided, it can instantiate
    the corresponding Type_Safe class to validate it before sending,
    catching errors early. On the output side, converting JSON to a
    Type_Safe object might be as simple as
    `result = SchemaClass(response_json)`, since the Type_Safe base
    class likely implements a constructor or method for parsing a dict.
    This way, consumers of the client deal with rich Python objects and
    not untyped dictionaries.

-   **Backward Compatibility:** The client library is the stable
    interface, so we aim to keep its methods backward-compatible. If the
    service changes an endpoint or schema, we update the client under
    the hood while preserving the method signature whenever possible. In
    cases where a breaking change is unavoidable, we can deprecate old
    methods and introduce new ones, or bump the client's major version.
    Because both client and server are in active development together
    (often by the same team), such changes are coordinated. For
    instance, if the server merges two endpoints into one, the client
    might implement the old two methods by both calling the new unified
    endpoint (perhaps with different parameters) to avoid forcing
    immediate changes on client code. The dual contract approach gives
    us flexibility: the REST API can change, but the client adapts to
    keep external usage consistent.

## Project Structure and Schema Sharing

We will maintain **separate repositories** (or at least separate Python
packages) for the service and its client library. For example, for the
Cache service:

-   **Service Repository** (e.g. `MGraph-AI__Service__Cache`): Contains
    the FastAPI service implementation. This includes the route classes,
    internal logic, and any persistence or caching mechanism. Notably,
    this repo **does not define its own schemas**; instead, it depends
    on the client package for the schema definitions. This means in the
    FastAPI route functions, we import classes from
    `mgraph_ai_cache_client.schemas` (for example) when declaring
    request/response types. By doing so, we guarantee the server and
    client use identical models.

-   **Client Repository** (e.g. `MGraph-AI__Service__Cache__Client`,
    Python package name `mgraph_ai_cache_client`): Contains the schema
    definitions and the client code. This package is versioned and can
    be published to PyPI for others to use. The layout might look like:

```
    mgraph_ai_cache_client/  
    ├── pyproject.toml  (or setup.py)  
    ├── README.md  
    ├── mgraph_ai_cache_client/  
    │   ├── __init__.py  
    │   ├── schemas/  
    │   │   ├── __init__.py  
    │   │   └── cache_models.py   # e.g., classes Schema__Cache__Store_Request, Schema__Cache__Item, etc.  
    │   ├── client.py        # Main client class (CacheClient)  
    │   ├── _endpoints.py    # (Optional) auto-generated low-level endpoint mapping/functions  
    │   └── utils.py         # (Optional) utilities (e.g., for local mode or auth)  
    └── tests/  
        ├── test_client_remote.py   # tests using an actual running server or mock server  
        └── test_client_local.py    # tests using in-memory FastAPI app  
```

In this structure, `cache_models.py` would define classes like
`CacheItem`, `CacheStoreRequest`, `CacheStoreResponse`, etc., all
subclassing `Type_Safe`. The `client.py` would define `CacheClient` with
high-level methods. Optionally, `_endpoints.py` could be a module
generated from the service's OpenAPI spec, containing a mapping of each
operation (with its URL path, HTTP method, and associated schema
classes). This separation can help in maintaining the client: you might
auto-generate `_endpoints.py` and then have `client.py` call those
generic functions or use that data. However, a simpler approach is to
generate the methods directly in `client.py`.

**Shared Schema Example:** If `CacheItem` is a Type_Safe class with
fields like `id: Safe_Str`, `data: dict`, etc., it will live in the
client's `schemas` module. The FastAPI server might have a route
function like:

```python
    # In service code
    from mgraph_ai_cache_client.schemas.cache_models import CacheItem, CacheStoreRequest

    class Routes_Cache(Fast_API__Routes):
        tag = "cache"

        def store_json(self, request: CacheStoreRequest) -> CacheItem:
            # ... (store logic) ...
            return CacheItem(id=stored_id, data=request.data)
        def get_item__id(self, id: Safe_Str) -> CacheItem:
            # ... retrieve item by id ...
            return CacheItem(id=id, data=...)
        def setup_routes(self):
            self.add_route_post(self.store_json)       # POST /cache/store-json
            self.add_route_get(self.get_item__id)      # GET /cache/get-item/{id}
```

In the above, the schemas `CacheStoreRequest` and `CacheItem` come from
the client package. The naming `get_item__id` will produce a path with
`{id}` as a path
param[[2]](https://pypi.org/project/osbot-fast-api/#:~:text=Route%20Path%20Generation).
The OpenAPI spec is generated from this and will also reference the
schema classes (via their definitions).

On the client side, we mirror these operations:

```python
    # In client.py
    from .schemas import cache_models

    class CacheClient:
        def __init__(self, base_url: str = "http://localhost:8000", app=None):
            if app:
                # Use FastAPI TestClient for local in-memory mode
                from fastapi.testclient import TestClient
                self._client = TestClient(app)
                self._base_url = ""  # not used in local mode
                self._local_mode = True
            else:
                self._client = None
                self._base_url = base_url
                self._local_mode = False

        def store_json(self, data: dict, strategy: str = "default", namespace: str = "default") -> cache_models.CacheItem:
            """Store a JSON payload in the cache and return a CacheItem handle."""
            url = f"{self._base_url}/{namespace}/{strategy}/store/json"
            if self._local_mode:
                response = self._client.post(url, json=data)
            else:
                import requests
                response = requests.post(url, json=data)
            response.raise_for_status()
            result_json = response.json()
            # Construct a CacheItem Type_Safe object from the JSON response
            return cache_models.CacheItem(result_json)  # CacheItem __init__ can take a dict
```
The above snippet illustrates a possible implementation. In
`store_json`, we build the URL using the base URL and the
namespace/strategy parameters (defaulting to "default"). If in local
mode, we use the `TestClient` (which behaves like `requests` but calls
the app
directly[[3]](https://pypi.org/project/osbot-fast-api/#:~:text=from%20osbot_fast_api));
otherwise we use `requests` to call the actual service. After getting
the JSON response, we create a `CacheItem` object from it. Because
`CacheItem` is a Type_Safe schema, this will validate the fields and
types immediately. The caller of `store_json` receives a `CacheItem`
instance ready to use.

**Handling Path and Query Parameters:** In the example above,
`store_json` doesn't have a path param (aside from parts of the URL).
For methods that retrieve or delete items by ID, the client method would
accept an `id` argument and include it in the URL path. For instance:

```python
        def get_item(self, item_id: str, namespace: str = "default") -> cache_models.CacheItem:
            """Retrieve a cached item by its ID."""
            url = f"{self._base_url}/{namespace}/retrieve/{item_id}"
            if self._local_mode:
                response = self._client.get(url)
            else:
                import requests
                response = requests.get(url)
            response.raise_for_status()
            return cache_models.CacheItem(response.json())
```
If the API uses query parameters (e.g., `GET /search?query=foo`), the
client method would accept those as arguments and pass them via the
`params` argument of `requests.get` (or TestClient `.get`). The idea is
to keep the method signature simple and intuitive, hiding whether
something is implemented as a path param or query param internally. The
naming convention used in the server (`get_item__id` for a path param)
helps in mapping these, but the client developer doesn't necessarily
need to use double-underscores; we can present it as `get_item(item_id)`
for clarity.

## Automating Client Code Generation

To minimize manual work and ensure consistency, we should automate as
much of the client code creation as possible. There are a few strategies
to consider:

-   **OpenAPI-driven generation:** FastAPI produces an OpenAPI JSON
    schema for the service, which includes all endpoints, their methods,
    paths, and request/response models. We can leverage this to generate
    client code. For example, a script can load the OpenAPI spec
    (available at runtime via `fast_api.app().openapi()`) and iterate
    over the paths. For each operation, it can determine the Python
    method name (perhaps based on the operationId or the endpoint path)
    and the expected request/response schema classes. Since our schema
    classes are in the client package, the generator can map OpenAPI
    component references to actual class names. This script could output
    a Python file (e.g. `_endpoints.py` or directly update `client.py`)
    with stub methods or a data structure for the endpoints.

-   **Introspection of route classes:** Since we have access to the
    service code (especially when client and server are developed
    together), another approach is to introspect the FastAPI routes
    directly. For instance, OSBot-Fast-API's route classes (subclassing
    `Fast_API__Routes`) might have metadata or naming patterns we can
    use. We saw above that route method names translate predictably to
    paths[[2]](https://pypi.org/project/osbot-fast-api/#:~:text=Route%20Path%20Generation).
    We could import the service's `Routes_Cache` class in a generation
    script and inspect its methods or use FastAPI's `app.routes` list to
    get all endpoint definitions. This might give us the path, the HTTP
    method, and the Python function that handles it (from which we can
    infer parameter names and types via annotations). However, using the
    OpenAPI spec is a more standardized approach and doesn't require
    importing server code (which could have side effects).

-   **Static vs Dynamic:** We prefer **static generation** of code to
    ensure that developers get autocompletion and to keep the client
    code explicit. Dynamic runtime generation (e.g. using `__getattr__`
    to catch calls) could reduce boilerplate, but it makes the library
    harder to understand and less friendly to IDEs. Therefore, our plan
    is to use a generator to produce actual method definitions. These
    methods can then be refined or given docstrings, etc., if needed.
    The generation script can be re-run whenever the API changes.

**Example Auto-Generation Workflow:** We might include a CLI command or
script in the client repo (for example, `generate_client.py`). This
script could:

1.  Spin up the FastAPI app from the service (possibly by importing the
    app object or running the app in a thread).
2.  Retrieve the OpenAPI JSON (e.g., by calling the app's `.openapi()`
    method).
3.  Parse the JSON to find all operations. For each operation, determine
    a suitable Python method name. For instance, an operationId of
    "store_json_cache_cache_post" (just an example OpenAPI naming)
    could map to `store_json()` in the client. We may also use the
    `tags` or path segments to organize methods (for clarity, perhaps
    group by service component).
4.  Determine the request body schema (if any) and response schema for
    the operation by looking at OpenAPI components. Map those to the
    classes in our `schemas` module (since they should have identical
    names).
5.  Write or update the `client.py` file with a method definition. The
    method body template would depend on the HTTP verb: for GET, use
    `requests.get` with params; for POST/PUT, use `.post` with JSON
    payload (after converting a Type_Safe object to dict if the user
    passes one); etc. Include `response.raise_for_status()` for error
    handling and conversion of the result to the appropriate Type_Safe
    class. If an endpoint returns just a primitive (say a string or
    int), we can return that directly.

We can annotate these methods with the expected types using our schema
classes for better type hints. For example:
`def store_json(...) -> CacheItem:` as shown, so that an IDE knows the
return type is `CacheItem`.

The generation script can run **manually during development** or as part
of a CI pipeline (see next section). By automating, we ensure that when
the service interface changes, the client can be updated with minimal
effort and without forgetting any endpoints. For initial development, we
might hand-write a couple of methods to set style, then gradually move
to generation as the number of endpoints grows.

## CI/CD: Keeping Client and Server in Sync

To successfully implement the dual contract pattern, it's crucial to
keep the client library synchronized with the service API. We can
achieve this with a combination of continuous integration checks and
automation:

-   **Shared Tests:** One effective technique is to **test the service
    using the client library**. In the service repository's test suite,
    include the client package (install it from source or as a dev
    dependency). Write integration tests that start the FastAPI app
    (perhaps with `Fast_API_Server` or TestClient) and then call client
    methods. For example, a test might spin up the Cache service app and
    then do:

```python
    from mgraph_ai_cache_client import CacheClient, schemas
    def test_store_and_retrieve():
        fast_api = Fast_API()
        fast_api.setup()
        fast_api.add_routes(Routes_Cache)
        app = fast_api.app()
        client = CacheClient(app=app)  # local mode
        data = {"foo": "bar"}
        result = client.store_json(data)
        assert isinstance(result, schemas.CacheItem)
        # Now retrieve it
        fetched = client.get_item(result.id)
        assert fetched.data == data
```

This kind of test, run in the service's CI, serves two purposes: it
verifies the service functionality end-to-end, and it instantly reveals
if the client is out-of-sync with the service. If, for instance, the
service changed an endpoint or response format and the client wasn't
updated, these tests would fail. This gives immediate feedback to the
developer to update the client code or schema. Essentially, the client
tests double as contract tests between the service and client.

-   **OpenAPI Snapshot Comparison:** Another CI strategy is to treat the
    OpenAPI spec as a contract artifact. We can store a *snapshot* of
    the service's OpenAPI JSON (or a filtered version of it) in the
    client repository. Whenever the service code changes, we generate
    the new OpenAPI and compare it to the snapshot:
-   If there are no changes (the JSON is identical), then the service
    API contract hasn't changed; the client should continue to work
    without modifications.
-   If there are changes (different paths, new fields, etc.), that
    indicates a contract update. We then need to update the client. This
    could be automated by a CI job: for example, a GitHub Action in the
    service repo could on each commit run the OpenAPI generator, diff it
    with the copy in the client repo, and if differences are found,
    either fail the build with a message or even automatically open a
    pull request on the client repo with the updated spec and
    regenerated code.

By automating this check, we avoid the scenario of "forgetting" to
update the client. The existence of a discrepancy becomes visible
immediately. This also forces conscious decision-making about
versioning: if an incompatible change is made, we might choose to bump
the client's version or maintain backward compatibility logic as
discussed.

-   **CI for Client Repo:** The client library itself will have its own
    CI pipeline. When changes are made to the client code (or when
    triggered by the server CI as above), the client's tests should run.
    These tests can include using a **live server or a dummy app** to
    simulate responses. Ideally, for full integration, the client tests
    will start the actual FastAPI service (perhaps by importing the
    Routes class and using FastAPI's TestClient, similar to the shared
    test described). In a simpler scenario, the client tests could use
    **contract mocks** -- e.g., start a local HTTP server stub that
    returns expected data -- but since we have the real service
    available, it's better to test against it directly. We can achieve
    this by treating the service code as a submodule or dev dependency
    in the client tests, or by calling the service's app factory in the
    client tests.

-   **Automatic Release Process:** If the service and client are tightly
    coupled in development, one could consider automating the release of
    the client whenever the service changes. For instance, upon merging
    a change to the service's main branch that affects the API, one
    could have a pipeline job that updates the client code, bumps the
    client package version, and pushes a new release to the package
    registry. This may be configured with appropriate checks (maybe
    requiring a developer to approve the changes or verify the version
    bump). The automation could run the generation script mentioned
    earlier to update method definitions. All of this ensures rapid
    propagation of changes: as soon as the new service is live, the
    updated client is available for others to install.

-   **Versioning Strategy:** We will use semantic versioning for the
    client library. Backward-compatible additions or fixes will bump the
    minor or patch version. Breaking changes (which correspond to
    significant API changes in the service) would result in a major
    version bump. The CI can enforce that if a snapshot diff indicates a
    breaking change (e.g. removal or renaming of an endpoint or required
    field), the client version must be incremented appropriately. In
    practice, since this is an internal project, we might not maintain
    multiple major versions for long -- we'd likely upgrade all
    consumers in lockstep. But having the versioning clear helps track
    compatibility.

## Example Usage and Testing

Below are a couple of scenarios demonstrating how the client can be used
by developers and tested in different modes:

-   **Using the Client in an Application (Remote Mode):** Suppose
    another service or script wants to use the cache. After installing
    `mgraph_ai_cache_client`, they can do:

```python
    from mgraph_ai_cache_client import CacheClient, schemas

    cache = CacheClient(base_url="https://cache.example.com")  # URL of deployed service
    data = {"user": "alice", "actions": ["login", "view"]}
    result = cache.store_json(data, namespace="audit")  
    # result is a schemas.CacheItem object with an id and data
    print("Stored cache item ID:", result.id)

    fetched = cache.get_item(result.id, namespace="audit")
    assert fetched.data == data
```

The developer didn't need to know anything about HTTP status codes or
routes -- the client handled it. If the service required authentication
(e.g., API keys or tokens), the client could also handle that (for
example, by allowing an `api_key` on initialization and adding the
header to each request).

-   **Client Testing in Local Mode:** For development or CI, we can run
    tests without deploying the service to an external URL. Using
    FastAPI's in-memory server makes tests fast and hermetic. For
    example:

```python
    from mgraph_ai_cache_client import CacheClient
    from service_code import create_app   # suppose this function builds the FastAPI app

    def test_store_and_retrieve_local():
        app = create_app()  # create FastAPI app with Routes_Cache included
        client = CacheClient(app=app)     # use local in-memory calls
        data = {"value": 123}
        item = client.store_json(data)
        # The returned item should be a CacheItem with the same data
        assert item.data == data
        # Now retrieve it back
        item_again = client.get_item(item.id)
        assert item_again.data == data
        assert item_again.id == item.id
```

In this snippet, `CacheClient(app=app)` sets up the client to use a
`TestClient` internally, so `store_json` calls `app`
directly[[3]](https://pypi.org/project/osbot-fast-api/#:~:text=from%20osbot_fast_api).
This test is effectively an integration test of the whole system, but it
runs in milliseconds and without any network. We can include such tests
in the client's repository (using the actual service code by importing
it or via a fixture). This ensures the client truly works with the
latest service logic.

## CI/CD Integration for Client Sync

*(Summary of CI/CD steps for clarity)*

**Service CI Pipeline:**

-   Run unit tests and integration tests, including those that use the
    client library to call the service.

-   After tests, run an **API contract check**: generate OpenAPI spec
    and diff with stored snapshot.
    -   If differences found: auto-update or alert. For example, run the
        client code generator and commit changes in a separate branch or
        job. Ensure the version is bumped if needed.

-   Optionally, trigger the client repo's CI if changes are made or on a
    schedule to ensure compatibility.

**Client CI Pipeline:**

-   Run the client's own tests. These tests can start the FastAPI app
    from the service (the service code might be included as a dev
    requirement or pulled via Git submodule). This verifies that the
    client calls succeed against the actual service implementation.

-   Linting/type-checking to ensure the generated code is clean and all
    schema references resolve correctly.

-   Package build (wheel/sdist) and (if part of release) publish to PyPI
    or internal registry.

**Automated Publishing:** 

-   If using GitHub Actions, one can set up a
    workflow for the client library such that when code is pushed to
    main (or a new release tag is made), it automatically publishes the
    new version. Coupled with the service's workflow that might push
    changes to the client, this results in a continuous delivery of
    client updates.

By adhering to these practices, we maintain the **duality** of the API
contract effectively: the service can evolve swiftly, and the client
library remains a dependable interface for any consumer. The combination
of **shared schema classes**, **automated client generation**, and
**joint testing** creates a robust development loop where issues are
caught early and improvements can be delivered to users of the client
with minimal delay. This ensures that even as our FastAPI services grow
more powerful or complex, the integration experience for other
developers (or AI agents) using those services stays smooth and
reliable.