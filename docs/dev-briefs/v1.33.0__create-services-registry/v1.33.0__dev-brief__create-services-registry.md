# Dev Brief: Create Services Registry

**Version**: v1.33.0  
**Date**: January 2025  
**Status**: Ready for Implementation  
**Target Package**: `osbot_fast_api_serverless`

---

## Executive Summary

This document specifies the implementation of a **Services Registry** — a centralized, service-agnostic mechanism for registering and discovering FastAPI service clients across multiple deployment modes. The registry enables the same business logic code to run unchanged whether services are deployed as distributed microservices (REMOTE mode) or collapsed into a single process (IN_MEMORY mode).

### Key Outcomes

1. **Zero code changes** in business logic when switching deployment modes
2. **Explicit registration** at startup for predictable behavior
3. **Type-safe client retrieval** indexed by client class type
4. **Backwards compatible** with existing env var configuration
5. **Test isolation** via `clear()` method

---

## Architectural Context

### The Problem

Current service discovery is fragmented:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CURRENT STATE (Fragmented)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   REMOTE Mode:                        IN_MEMORY Mode:                       │
│   ─────────────                       ──────────────                        │
│   • Read env vars at runtime          • Direct injection of FastAPI app     │
│   • URL__TARGET_SERVER__CACHE         • Must wire up at construction time   │
│   • Each client handles its own       • No central coordination             │
│     configuration                                                           │
│                                                                             │
│   Problem: Deep code can't discover   Problem: Requires passing clients     │
│   which mode it's in or get clients   through entire call stack             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### The Solution

A centralized registry that abstracts service discovery:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    TARGET STATE (Unified)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                      ┌─────────────────────────┐                            │
│                      │   Services__Registry    │                            │
│                      │                         │                            │
│                      │   register(client)      │                            │
│                      │   client(client_type)   │                            │
│                      │   clear()               │                            │
│                      └───────────┬─────────────┘                            │
│                                  │                                          │
│              ┌───────────────────┼───────────────────┐                      │
│              │                   │                   │                      │
│              ▼                   ▼                   ▼                      │
│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐               │
│   │ Cache Client    │ │ Html_Graph      │ │ Future Service  │               │
│   │ (IN_MEMORY)     │ │ Client (REMOTE) │ │ Client          │               │
│   └─────────────────┘ └─────────────────┘ └─────────────────┘               │
│                                                                             │
│   Business logic calls: Services__Registry.client(Cache__Client)            │
│   → Gets correct client regardless of deployment mode                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Deployment Modes Supported

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DEPLOYMENT MODE SPECTRUM                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   MODE 1: All-in-One Monolith              MODE 4+: Distributed             │
│   ─────────────────────────                ────────────────────             │
│   ┌─────────────────────────┐              ┌───────┐   ┌───────┐            │
│   │  Single Process         │              │ Cache │   │ HTML  │            │
│   │  ┌─────┐ ┌─────┐       │              │Service│   │Service│            │
│   │  │Cache│ │HTML │       │              └───┬───┘   └───┬───┘            │
│   │  │     │ │Graph│       │                  │           │                │
│   │  └─────┘ └─────┘       │              ────┴───────────┴────            │
│   │  TestClient routing    │                  Network (HTTP)               │
│   └─────────────────────────┘                                              │
│                                                                             │
│   Registry: IN_MEMORY clients              Registry: REMOTE clients        │
│   All services in same process             Services on separate hosts      │
│   Zero network latency                     Network latency + resilience    │
│                                                                             │
│   ──────────────────────────────────────────────────────────────────────    │
│                                                                             │
│   MODE: Hybrid                                                              │
│   ────────────                                                              │
│   Some services IN_MEMORY, others REMOTE                                   │
│   Example: Html_Graph local, Cache remote                                   │
│   Registry handles mixed configurations seamlessly                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Package Dependency Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    PACKAGE DEPENDENCY GRAPH                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  osbot_fast_api_serverless (this implementation)                    │   │
│   │                                                                     │   │
│   │  • Services__Registry              ◄── Service-agnostic registry    │   │
│   │  • Service__Client__Base           ◄── Base class for all clients   │   │
│   │  • Schema__Service__Client__Config ◄── Shared config schema         │   │
│   │  • Enum__Client__Mode              ◄── IN_MEMORY | REMOTE           │   │
│   │  • Safe primitives for API keys                                     │   │
│   └───────────────────────────┬─────────────────────────────────────────┘   │
│                               │                                             │
│                               │ (base dependency)                           │
│                               ▼                                             │
│   ┌───────────────────────────────────────┬─────────────────────────────┐   │
│   │  mgraph_ai_service_cache_client       │  mgraph_ai_service_         │   │
│   │                                       │  html_graph_client          │   │
│   │  • Cache__Service__Fast_API__Client   │  • Html_Graph__Service__    │   │
│   │    (extends Service__Client__Base)    │    Client                   │   │
│   │  • All Cache schemas                  │  • All Html_Graph schemas   │   │
│   │  • Request routing logic              │  • Request routing logic    │   │
│   └───────────────────┬───────────────────┴──────────────┬──────────────┘   │
│                       │                                  │                  │
│                       │ (import for schemas)             │                  │
│                       ▼                                  ▼                  │
│   ┌───────────────────────────────────────┬─────────────────────────────┐   │
│   │  mgraph_ai_service_cache              │  mgraph_ai_service_         │   │
│   │                                       │  html_graph                 │   │
│   │  • Cache__Service (backend)           │  • Html_Graph__Service      │   │
│   │  • Cache__Service__In_Memory          │  • Html_Graph__Service__    │   │
│   │  • FastAPI routes                     │    In_Memory                │   │
│   └───────────────────────────────────────┴─────────────────────────────┘   │
│                                                                             │
│   KEY INSIGHT:                                                              │
│   • __Client packages have NO knowledge of __Service implementations        │
│   • __Service packages import __Client for schemas                          │
│   • Registry lives in serverless package (no service dependencies)          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Implementation Specification

### File Structure

```
osbot_fast_api_serverless/
├── registry/
│   ├── __init__.py
│   ├── Services__Registry.py                    # Main registry class
│   ├── Service__Client__Base.py                 # Base class for clients
│   ├── Schema__Service__Client__Config.py       # Config schema
│   ├── Dict__Clients__By_Type.py                # Type-safe dict for storage
│   └── enums/
│       ├── __init__.py
│       └── Enum__Client__Mode.py                # IN_MEMORY | REMOTE
├── primitives/
│   ├── __init__.py
│   ├── Safe_Str__API_Key__Name.py               # API key header name
│   └── Safe_Str__API_Key__Value.py              # API key header value
└── schemas/
    ├── __init__.py
    └── Schema__Env_Var.py                       # Env var definition
```

---

### Core Components

#### 1. Enum__Client__Mode

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/registry/enums/Enum__Client__Mode.py
# ═══════════════════════════════════════════════════════════════════════════════

from enum import Enum

class Enum__Client__Mode(Enum):
    IN_MEMORY = 'in_memory'                      # Uses FastAPI TestClient
    REMOTE    = 'remote'                         # Uses HTTP requests
```

#### 2. Safe Primitives for API Keys

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/primitives/Safe_Str__API_Key__Name.py
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Http__Header__Name import Safe_Str__Http__Header__Name

class Safe_Str__API_Key__Name(Safe_Str__Http__Header__Name):    # e.g., "X-API-KEY"
    pass
```

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/primitives/Safe_Str__API_Key__Value.py
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Http__Header__Value import Safe_Str__Http__Header__Value

class Safe_Str__API_Key__Value(Safe_Str__Http__Header__Value):  # The actual key
    pass
```

#### 3. Schema__Env_Var

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/schemas/Schema__Env_Var.py
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.Type_Safe                     import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Str      import Safe_Str

class Schema__Env_Var(Type_Safe):                        # Pure data - no methods
    name     : Safe_Str                                  # e.g., "URL__TARGET_SERVER__CACHE"
    required : bool      = True                          # Must be present at startup?
```

#### 4. List__Env_Vars

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/schemas/List__Env_Vars.py
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List
from osbot_fast_api_serverless.schemas.Schema__Env_Var                 import Schema__Env_Var

class List__Env_Vars(Type_Safe__List):                   # Expected env vars for a client
    expected_type = Schema__Env_Var
```

#### 5. Schema__Service__Client__Config

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/registry/Schema__Service__Client__Config.py
# ═══════════════════════════════════════════════════════════════════════════════

from typing                                                                      import Any
from fastapi                                                                     import FastAPI
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url         import Safe_Str__Url
from osbot_fast_api_serverless.registry.enums.Enum__Client__Mode                 import Enum__Client__Mode
from osbot_fast_api_serverless.primitives.Safe_Str__API_Key__Name                import Safe_Str__API_Key__Name
from osbot_fast_api_serverless.primitives.Safe_Str__API_Key__Value               import Safe_Str__API_Key__Value

class Schema__Service__Client__Config(Type_Safe):        # Pure data - no methods
    mode          : Enum__Client__Mode                   # IN_MEMORY or REMOTE
    fast_api_app  : FastAPI            = None            # For IN_MEMORY mode (TestClient target)
    base_url      : Safe_Str__Url                        # For REMOTE mode
    api_key_name  : Safe_Str__API_Key__Name              # HTTP header name for auth
    api_key_value : Safe_Str__API_Key__Value             # HTTP header value for auth
```

#### 6. Service__Client__Base

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/registry/Service__Client__Base.py
# Base class that all service clients must inherit
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_fast_api_serverless.registry.Schema__Service__Client__Config          import Schema__Service__Client__Config
from osbot_fast_api_serverless.schemas.List__Env_Vars                            import List__Env_Vars

class Service__Client__Base(Type_Safe):                  # Abstract base for all clients
    config : Schema__Service__Client__Config             # Configuration for this client

    def setup_from_env(self) -> 'Service__Client__Base': # Configure from environment variables
        raise NotImplementedError("Subclass must implement setup_from_env()")

    def requests(self):                                  # Return the *__Requests object
        raise NotImplementedError("Subclass must implement requests()")

    def health(self) -> bool:                            # Basic health check
        raise NotImplementedError("Subclass must implement health()")

    @classmethod
    def env_vars(cls) -> List__Env_Vars:                 # Expected env vars for this client
        raise NotImplementedError("Subclass must implement env_vars()")

    @classmethod
    def client_name(cls) -> str:                         # Human-readable name for errors
        return cls.__name__
```

#### 7. Dict__Clients__By_Type

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/registry/Dict__Clients__By_Type.py
# Type-safe dictionary for storing clients indexed by their class type
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict
from osbot_fast_api_serverless.registry.Service__Client__Base         import Service__Client__Base

class Dict__Clients__By_Type(Type_Safe__Dict):           # Maps client type → client instance
    expected_key_type   = type                           # The client class itself
    expected_value_type = Service__Client__Base          # Instance of client
```

#### 8. Services__Registry

```python
# ═══════════════════════════════════════════════════════════════════════════════
# osbot_fast_api_serverless/registry/Services__Registry.py
# Central registry for service client discovery
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_fast_api_serverless.registry.Dict__Clients__By_Type    import Dict__Clients__By_Type
from osbot_fast_api_serverless.registry.Service__Client__Base     import Service__Client__Base

class Services__Registry:                                # Static singleton registry
    _clients : Dict__Clients__By_Type = None             # Class-level storage (lazy init)

    @classmethod
    def clients(cls) -> Dict__Clients__By_Type:          # Lazy initialization of storage
        if cls._clients is None:
            cls._clients = Dict__Clients__By_Type()
        return cls._clients

    @classmethod
    def register(cls, client: Service__Client__Base) -> None:  # Register a client instance
        if client is None:
            raise ValueError("Cannot register None as a client")
        if not isinstance(client, Service__Client__Base):
            raise TypeError(f"Client must inherit from Service__Client__Base, got {type(client)}")
        cls.clients()[type(client)] = client             # Index by actual type

    @classmethod
    def client(cls, client_type: type) -> Service__Client__Base:  # Retrieve by type
        if client_type not in cls.clients():
            return None                                  # Not registered = None
        return cls.clients()[client_type]                # Return registered client

    @classmethod
    def is_registered(cls, client_type: type) -> bool:   # Check if type is registered
        return client_type in cls.clients()

    @classmethod
    def clear(cls) -> None:                              # Reset for test isolation
        cls._clients = None

    @classmethod
    def registered_types(cls) -> list:                   # List all registered client types
        return list(cls.clients().keys())
```

---

### Client Implementation Pattern

Each service client package implements a client that inherits from `Service__Client__Base`:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Example: mgraph_ai_service_cache_client/.../Cache__Service__Fast_API__Client.py
# ═══════════════════════════════════════════════════════════════════════════════

import os
from osbot_fast_api_serverless.registry.Service__Client__Base            import Service__Client__Base
from osbot_fast_api_serverless.registry.enums.Enum__Client__Mode         import Enum__Client__Mode
from osbot_fast_api_serverless.schemas.Schema__Env_Var                   import Schema__Env_Var
from osbot_fast_api_serverless.schemas.List__Env_Vars                    import List__Env_Vars
from mgraph_ai_service_cache_client.client.client_contract.Cache__Service__Fast_API__Client__Config   import Cache__Service__Fast_API__Client__Config
from mgraph_ai_service_cache_client.client.client_contract.Cache__Service__Fast_API__Client__Requests import Cache__Service__Fast_API__Client__Requests

class Cache__Service__Fast_API__Client(Service__Client__Base):
    config : Cache__Service__Fast_API__Client__Config    # Client-specific config

    @classmethod
    def env_vars(cls) -> List__Env_Vars:                 # Document expected env vars
        return List__Env_Vars([
            Schema__Env_Var(name='URL__TARGET_SERVER__CACHE_SERVICE', required=True ),
            Schema__Env_Var(name='API_KEY__CACHE_SERVICE'           , required=False)
        ])

    def setup_from_env(self) -> 'Cache__Service__Fast_API__Client':
        url = os.environ.get('URL__TARGET_SERVER__CACHE_SERVICE')
        if not url:
            raise ValueError("URL__TARGET_SERVER__CACHE_SERVICE not set")
        self.config.base_url = url
        self.config.mode     = Enum__Client__Mode.REMOTE

        api_key = os.environ.get('API_KEY__CACHE_SERVICE')
        if api_key:
            self.config.api_key_name  = 'X-API-KEY'
            self.config.api_key_value = api_key

        return self

    def requests(self) -> Cache__Service__Fast_API__Client__Requests:
        return Cache__Service__Fast_API__Client__Requests(config=self.config)

    def health(self) -> bool:
        return self.info().health().get('status') == 'ok'

    # Domain-specific methods
    def store(self)    -> Cache__Store:    return Cache__Store(requests=self.requests())
    def retrieve(self) -> Cache__Retrieve: return Cache__Retrieve(requests=self.requests())
    def info(self)     -> Cache__Info:     return Cache__Info(requests=self.requests())
```

---

## Usage Patterns

### Pattern A: Full Standalone (Air-Gapped / Testing)

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Startup for standalone mode - all services in-memory
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_fast_api_serverless.registry.Services__Registry               import Services__Registry
from mgraph_ai_service_cache.service.cache.in_memory.Cache__Service__In_Memory         import Cache__Service__In_Memory
from mgraph_ai_service_html_graph.service.in_memory.Html_Graph__Service__In_Memory     import Html_Graph__Service__In_Memory

def setup_standalone():
    # 1. Create in-memory services (wires up FastAPI apps internally)
    cache_in_memory = Cache__Service__In_Memory().setup()

    html_in_memory = Html_Graph__Service__In_Memory().setup(
        cache_client=cache_in_memory.cache_client          # Inject cache dependency
    )

    # 2. Register clients with the registry
    Services__Registry.register(cache_in_memory.cache_client)
    Services__Registry.register(html_in_memory.html_graph_client)

    # Now any code can discover these clients via the registry
```

### Pattern B: Production (Remote Services)

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Startup for production - all services remote via HTTP
# Requires env vars: URL__TARGET_SERVER__CACHE_SERVICE, etc.
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_fast_api_serverless.registry.Services__Registry                        import Services__Registry
from mgraph_ai_service_cache_client.client.client_contract.Cache__Service__Fast_API__Client   import Cache__Service__Fast_API__Client
from mgraph_ai_service_html_graph.client.Html_Graph__Service__Client              import Html_Graph__Service__Client

def setup_production():
    # 1. Create clients configured from environment variables
    cache_client = Cache__Service__Fast_API__Client().setup_from_env()
    html_client  = Html_Graph__Service__Client().setup_from_env()

    # 2. Register them
    Services__Registry.register(cache_client)
    Services__Registry.register(html_client)
```

### Pattern C: Hybrid (Mixed Modes)

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Hybrid: Some services local, others remote
# Example: Developing Html_Graph locally against remote Cache
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_fast_api_serverless.registry.Services__Registry                        import Services__Registry
from mgraph_ai_service_cache_client.client.client_contract.Cache__Service__Fast_API__Client   import Cache__Service__Fast_API__Client
from mgraph_ai_service_html_graph.service.in_memory.Html_Graph__Service__In_Memory            import Html_Graph__Service__In_Memory

def setup_hybrid():
    # Cache is remote (from env vars)
    cache_client = Cache__Service__Fast_API__Client().setup_from_env()
    Services__Registry.register(cache_client)

    # Html_Graph is local (in-memory), uses the remote cache
    html_in_memory = Html_Graph__Service__In_Memory().setup(
        cache_client=cache_client                          # Uses remote cache!
    )
    Services__Registry.register(html_in_memory.html_graph_client)
```

### Consuming Services (Business Logic)

```python
# ═══════════════════════════════════════════════════════════════════════════════
# How business logic discovers and uses services
# This code works identically in all deployment modes
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_fast_api_serverless.registry.Services__Registry                        import Services__Registry
from mgraph_ai_service_cache_client.client.client_contract.Cache__Service__Fast_API__Client   import Cache__Service__Fast_API__Client

class Html_Graph__Service(Type_Safe):

    def cache_client(self) -> Cache__Service__Fast_API__Client:
        client = Services__Registry.client(Cache__Service__Fast_API__Client)
        if client is None:
            raise ValueError(
                f"Cache client not registered. "
                f"Call Services__Registry.register() at startup."
            )
        return client

    def store_html(self, url: str, html: str):
        # This code has NO IDEA if cache is in-memory or remote
        # It just works!
        cache_key = self.url_to_cache_key(url)
        self.cache_client().store().store__json__cache_key(
            namespace = 'html-graph',
            cache_key = cache_key,
            body      = {'html': html},
            ...
        )
```

### Test Setup Pattern

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Test setup with proper isolation
# ═══════════════════════════════════════════════════════════════════════════════

from unittest import TestCase
from osbot_fast_api_serverless.registry.Services__Registry import Services__Registry

class test_Html_Graph__Service__Integration(TestCase):

    @classmethod
    def setUpClass(cls):
        Services__Registry.clear()                       # Clean slate

        # Setup full in-memory stack
        cls.cache_in_memory = Cache__Service__In_Memory().setup()
        Services__Registry.register(cls.cache_in_memory.cache_client)

        cls.html_in_memory = Html_Graph__Service__In_Memory().setup(
            cache_client=cls.cache_in_memory.cache_client
        )
        Services__Registry.register(cls.html_in_memory.html_graph_client)

    @classmethod
    def tearDownClass(cls):
        Services__Registry.clear()                       # Cleanup for other tests

    def test__store_and_load(self):
        # Business logic under test uses Services__Registry.client(...)
        # Gets our in-memory clients automatically
        html_service = Html_Graph__Service()
        result = html_service.store_html("https://example.com", "<html>...")
        assert result.success is True
```

---

## Test Specification

### Unit Tests for Services__Registry

```python
# ═══════════════════════════════════════════════════════════════════════════════
# tests/unit/osbot_fast_api_serverless/registry/test_Services__Registry.py
# ═══════════════════════════════════════════════════════════════════════════════

from unittest                                                        import TestCase
from osbot_utils.utils.Objects                                       import base_classes
from osbot_fast_api_serverless.registry.Services__Registry           import Services__Registry
from osbot_fast_api_serverless.registry.Service__Client__Base        import Service__Client__Base
from osbot_fast_api_serverless.registry.Dict__Clients__By_Type       import Dict__Clients__By_Type


class Mock__Client(Service__Client__Base):               # Test double
    def setup_from_env(self): return self
    def requests(self): return None
    def health(self): return True
    @classmethod
    def env_vars(cls): return []


class test_Services__Registry(TestCase):

    def setUp(self):
        Services__Registry.clear()                       # Isolate each test

    def tearDown(self):
        Services__Registry.clear()

    def test__clients__lazy_init(self):
        assert Services__Registry._clients is None       # Not yet initialized
        clients = Services__Registry.clients()
        assert type(clients) is Dict__Clients__By_Type
        assert Services__Registry._clients is clients    # Now initialized

    def test__register__valid_client(self):
        client = Mock__Client()
        Services__Registry.register(client)
        assert Services__Registry.is_registered(Mock__Client)
        assert Services__Registry.client(Mock__Client) is client

    def test__register__none__raises(self):
        with self.assertRaises(ValueError) as context:
            Services__Registry.register(None)
        assert "Cannot register None" in str(context.exception)

    def test__register__invalid_type__raises(self):
        with self.assertRaises(TypeError) as context:
            Services__Registry.register("not a client")
        assert "must inherit from Service__Client__Base" in str(context.exception)

    def test__client__not_registered__returns_none(self):
        result = Services__Registry.client(Mock__Client)
        assert result is None

    def test__is_registered__false_when_not_registered(self):
        assert Services__Registry.is_registered(Mock__Client) is False

    def test__clear__resets_registry(self):
        client = Mock__Client()
        Services__Registry.register(client)
        assert Services__Registry.is_registered(Mock__Client)

        Services__Registry.clear()

        assert Services__Registry._clients is None
        assert Services__Registry.is_registered(Mock__Client) is False

    def test__registered_types__returns_all_types(self):
        client1 = Mock__Client()
        Services__Registry.register(client1)

        types = Services__Registry.registered_types()
        assert Mock__Client in types

    def test__multiple_clients__different_types(self):

        class Another__Client(Service__Client__Base):
            def setup_from_env(self): return self
            def requests(self): return None
            def health(self): return True
            @classmethod
            def env_vars(cls): return []

        client1 = Mock__Client()
        client2 = Another__Client()

        Services__Registry.register(client1)
        Services__Registry.register(client2)

        assert Services__Registry.client(Mock__Client)    is client1
        assert Services__Registry.client(Another__Client) is client2
```

### Unit Tests for Service__Client__Base

```python
# ═══════════════════════════════════════════════════════════════════════════════
# tests/unit/osbot_fast_api_serverless/registry/test_Service__Client__Base.py
# ═══════════════════════════════════════════════════════════════════════════════

from unittest                                                        import TestCase
from osbot_utils.utils.Objects                                       import base_classes
from osbot_utils.type_safe.Type_Safe                                 import Type_Safe
from osbot_fast_api_serverless.registry.Service__Client__Base        import Service__Client__Base


class test_Service__Client__Base(TestCase):

    def test__init__(self):
        with Service__Client__Base() as _:
            assert type(_)         is Service__Client__Base
            assert base_classes(_) == [Type_Safe, object]

    def test__setup_from_env__raises_not_implemented(self):
        client = Service__Client__Base()
        with self.assertRaises(NotImplementedError):
            client.setup_from_env()

    def test__requests__raises_not_implemented(self):
        client = Service__Client__Base()
        with self.assertRaises(NotImplementedError):
            client.requests()

    def test__health__raises_not_implemented(self):
        client = Service__Client__Base()
        with self.assertRaises(NotImplementedError):
            client.health()

    def test__env_vars__raises_not_implemented(self):
        with self.assertRaises(NotImplementedError):
            Service__Client__Base.env_vars()

    def test__client_name__returns_class_name(self):
        assert Service__Client__Base.client_name() == 'Service__Client__Base'
```

---

## Migration Guide

### Updating Existing Clients

Existing clients need minimal changes to support the registry:

```python
# BEFORE: Client manages its own config
class Cache__Service__Fast_API__Client(Type_Safe):
    config : Cache__Service__Fast_API__Client__Config
    ...

# AFTER: Client inherits from Service__Client__Base
from osbot_fast_api_serverless.registry.Service__Client__Base import Service__Client__Base

class Cache__Service__Fast_API__Client(Service__Client__Base):
    config : Cache__Service__Fast_API__Client__Config    # Keep existing config

    @classmethod
    def env_vars(cls) -> List__Env_Vars:                 # NEW: Document env vars
        return List__Env_Vars([...])

    def setup_from_env(self) -> 'Cache__Service__Fast_API__Client':  # NEW: Required
        # Existing env var setup logic
        return self

    def health(self) -> bool:                            # NEW: Required
        return self.info().health().get('status') == 'ok'

    # Existing methods unchanged
    def store(self): ...
    def retrieve(self): ...
```

### Updating Service Consumers

```python
# BEFORE: Service creates its own client
class Html_Graph__Service(Type_Safe):
    cache_client : Cache__Service__Fast_API__Client = None

    def __init__(self, cache_client=None):
        if cache_client:
            self.cache_client = cache_client
        else:
            self.cache_client = Cache__Service__Fast_API__Client().setup_from_env()

# AFTER: Service discovers client via registry
class Html_Graph__Service(Type_Safe):

    def cache_client(self) -> Cache__Service__Fast_API__Client:
        client = Services__Registry.client(Cache__Service__Fast_API__Client)
        if client is None:
            raise ValueError("Cache client not registered")
        return client
```

---

## Error Handling

### Registration Errors

| Error | Cause | Resolution |
|-------|-------|------------|
| `ValueError: Cannot register None` | Passed `None` to `register()` | Ensure client is properly instantiated |
| `TypeError: must inherit from Service__Client__Base` | Wrong type passed | Client must extend `Service__Client__Base` |

### Discovery Errors

| Situation | Behavior | Recommended Handling |
|-----------|----------|---------------------|
| Client not registered | Returns `None` | Raise descriptive error with setup instructions |
| Multiple registrations of same type | Last registration wins | Log warning if needed |

---

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Storage mechanism | `Dict__Clients__By_Type` | Type-safe, runtime validation |
| Key type | `type` (class itself) | Natural indexing, IDE support |
| Unregistered behavior | Return `None` | Explicit > implicit; caller decides error handling |
| Base class | `Service__Client__Base` (not ABC) | Type_Safe compatibility, `raise NotImplementedError` pattern |
| Env var fallback | **No automatic creation** | Explicit registration prevents hidden behavior |
| Test isolation | `clear()` method | Essential for test independence |
| API key types | Custom Safe_Str subclasses | Domain-specific validation |
| FastAPI app type | `FastAPI` (not `Any`) | Proper type checking |

---

## Summary Checklist

### Implementation Checklist

- [ ] Create `Enum__Client__Mode` (IN_MEMORY, REMOTE)
- [ ] Create `Safe_Str__API_Key__Name` extending `Safe_Str__Http__Header__Name`
- [ ] Create `Safe_Str__API_Key__Value` extending `Safe_Str__Http__Header__Value`
- [ ] Create `Schema__Env_Var` (name, required)
- [ ] Create `List__Env_Vars` extending `Type_Safe__List`
- [ ] Create `Schema__Service__Client__Config` with FastAPI type
- [ ] Create `Service__Client__Base` with NotImplementedError methods
- [ ] Create `Dict__Clients__By_Type` extending `Type_Safe__Dict`
- [ ] Create `Services__Registry` with register/client/clear methods
- [ ] Write unit tests for all components
- [ ] Update existing clients to extend `Service__Client__Base`

### Integration Checklist

- [ ] Update `Cache__Service__Fast_API__Client` to extend base
- [ ] Update `Html_Graph__Service__Client` to extend base
- [ ] Update services to discover clients via registry
- [ ] Update test fixtures to use `Services__Registry.clear()`
- [ ] Document startup patterns for each deployment mode

---

## References

- **Type_Safe Guide**: `v3_63_4__for_llms__type_safe.md`
- **Collections Guide**: `v3_63_3__for_llms__type_safe__collections__subclassing_guide.md`
- **Python Formatting Guide**: `v3_63_4__for_llms__python_formatting_guide.md`
- **Standalone Architecture PDF**: `22_Jan_-_Standalone_System_Architecture.pdf`
- **Deployment Modes PDF**: `23_Jan-_Deployment_Modes_Scaling_the_MiTM_Proxy.pdf`
