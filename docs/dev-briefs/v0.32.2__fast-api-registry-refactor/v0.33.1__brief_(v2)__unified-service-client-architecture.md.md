# Development Brief (v2): Unified Service Client Architecture

**Version**: v0.33.1  
**Date**: January 2025  
**Status**: Proposed  
**Affected Projects**: 
- `osbot_fast_api`
- `mgraph_ai_service_cache_client`
- `mgraph_ai_service_cache`
- `mgraph_ai_service_html_graph_client`
- `mgraph_ai_service_html_graph`
- Future service clients

---

## Executive Summary

This document describes a unified architecture for FastAPI service clients that enables seamless switching between IN_MEMORY (TestClient) and REMOTE (HTTP) modes without code changes. The architecture centralizes transport logic, eliminates redundant wrapper classes, and establishes clear patterns for all current and future service clients.

**Key insight**: The registry stores **configs keyed by client type**, not client instances. Client classes become stateless facades that look up their config from the registry at request time.

---

## Part 1: How We Got Here

### 1.1 Original Problem

Our microservices architecture had grown organically, resulting in:

- **Duplicate transport logic** in every service client
- **Multiple wrapper classes** per service (e.g., `Cache__Service__Fast_API__Client`, `Cache__Service__In_Memory`, `Cache__Service__Registry__Client`)
- **Inconsistent patterns** across different service clients
- **Config duplication** between registry and client configs
- **Unclear ownership** of the FastAPI app in IN_MEMORY mode

### 1.2 The Registry Pattern (Phase 1)

We first introduced `Fast_API__Service__Registry` to centralize service discovery:

```python
# Registration
registry.register(cache_client)

# Discovery
cache_client = registry.client(Cache__Service__Registry__Client)
```

This solved discovery but introduced new problems:
- Registry client wrapper (`Cache__Service__Registry__Client`) duplicating the actual client (`Cache__Service__Fast_API__Client`)
- Config fields duplicated between `Fast_API__Service__Registry__Client__Config` and `Cache__Service__Fast_API__Client__Config`

### 1.3 Questioning `Cache__Service__In_Memory` (Phase 2)

We asked: **"Why do we need the `Cache__Service__In_Memory` class?"**

Analysis revealed it was mixing two concerns:
1. **Server-side**: Creating `Cache__Service` + `Cache_Service__Fast_API`
2. **Client-side**: Creating `Cache__Service__Fast_API__Client`

The insight: This class is just **bootstrapping glue**. The client doesn't need to know how the FastAPI app was created — it just needs a configured `fast_api_app` in its config.

**Decision**: Replace `Cache__Service__In_Memory` with a simple registration function.

### 1.4 Package Dependency Analysis (Phase 3)

Understanding the one-way dependency was critical:

```
mgraph_ai_service_cache (heavy - has FastAPI, routes, business logic)
    │
    └── depends on ──► mgraph_ai_service_cache_client (light - schemas, client only)
```

**Key constraints**:
- Client package **never** imports from Service package
- All schemas live in Client package
- Service package can create FastAPI apps; Client package cannot

**Mode availability by installation**:

| Installed | Available Modes |
|-----------|----------------|
| Client only | REMOTE only |
| Client + Service | REMOTE and IN_MEMORY |

### 1.5 Discovering the Generic Transport (Phase 4)

Examining `Cache__Service__Fast_API__Client__Requests`, we realized it was **100% generic**:

```python
def execute(self, method, path, body, headers):
    if self.config.mode == IN_MEMORY:
        return self._execute_in_memory(...)   # TestClient
    else:
        return self._execute_remote(...)      # requests library
```

Nothing Cache-specific. This class should live in `osbot_fast_api` and be shared by all service clients.

**Decision**: Promote to `Fast_API__Client__Requests` in `osbot_fast_api`.

### 1.6 Eliminating Wrapper Layers (Phase 5)

We had three classes doing one job:

```
Cache__Service__Fast_API__Client      # Domain methods
Cache__Service__Registry__Client      # Registry wrapper  
Cache__Service__In_Memory             # Setup helper
```

**Decision**: Merge into single `Cache__Service__Client`.

### 1.7 Cleaning Up Naming (Phase 6)

Names like `Cache__Service__Registry__Client` leak implementation details. The "Registry" is **how** it's managed, not **what** it is.

**Before**:
- `Cache__Service__Fast_API__Client`
- `Cache__Service__Registry__Client`

**After**:
- `Cache__Service__Client`

The inheritance (`extends Fast_API__Service__Registry__Client__Base`) communicates registry compatibility — the name doesn't need to.

### 1.8 Registry Stores Config, Not Instances (Phase 7)

Final refinement: The registry should store **config objects keyed by client type**, not client instances.

**Why?**
- Client classes become **stateless facades**
- No repeated registry lookups (config fetched once per request chain)
- Simpler mental model: registry = "what config does this service type use?"
- Domain operation classes receive `requests` object, not `_client` — breaks circular dependencies

**Before**:
```python
registry.register(client_instance)
client = registry.client(ClientType)
config = client.config
```

**After**:
```python
registry.register(Cache__Service__Client, config)
config = registry.config(Cache__Service__Client)
```

---

## Part 2: Final Architecture

### 2.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Application Layer                                  │
│  (Business logic uses stateless client facades)                             │
│                                                                             │
│    client = Cache__Service__Client()                                        │
│    client.store().store__json__cache_key(...)                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Service Client Layer                                 │
│  (Domain-specific clients in each *_client package)                         │
│                                                                             │
│    Cache__Service__Client       → store(), retrieve(), info(), ...          │
│    Html__Service__Client        → transform(), process(), info(), ...       │
│    Html_Graph__Service__Client  → render(), export(), info(), ...           │
│    LLM__Service__Client         → complete(), embed(), info(), ...          │
│                                                                             │
│    Each extends Fast_API__Service__Registry__Client__Base                   │
│    Each has its OWN domain-specific methods (no overlap except info())      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Infrastructure Layer                                  │
│  (Generic transport in osbot_fast_api)                                      │
│                                                                             │
│    Fast_API__Service__Registry           - Config storage by client type    │
│    Fast_API__Service__Registry__Client__Base    - Base class for clients    │
│    Fast_API__Service__Registry__Client__Config  - Shared config schema      │
│    Fast_API__Client__Requests            - Generic IN_MEMORY/REMOTE transport│
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Package Structure

#### osbot_fast_api (Infrastructure)

```
osbot_fast_api/
└── services/
    └── registry/
        ├── Fast_API__Service__Registry.py
        ├── Fast_API__Service__Registry__Client__Base.py
        └── Fast_API__Client__Requests.py
    └── schemas/
        └── registry/
            ├── Fast_API__Service__Registry__Client__Config.py
            ├── enums/
            │   └── Enum__Fast_API__Service__Registry__Client__Mode.py
            └── collections/
                └── Dict__Fast_API__Service__Configs_By_Type.py
```

#### mgraph_ai_service_cache_client (Domain Client)

```
mgraph_ai_service_cache_client/
└── client/
    ├── Cache__Service__Client.py           # Main client class (stateless facade)
    ├── Cache__Service__Client__Requests.py # Extends Fast_API__Client__Requests
    ├── store/
    │   └── Service__Client__File__Store.py # Receives requests, not _client
    ├── retrieve/
    │   └── Service__Client__File__Retrieve.py
    └── ... (other domain operations)
└── schemas/
    └── ... (all schemas)
```

#### mgraph_ai_service_cache (Service - Registration Helpers)

```
mgraph_ai_service_cache/
└── registration/
    └── register_cache_service.py           # Simple function, not a class
```

### 2.3 Class Definitions

#### Fast_API__Service__Registry (Config Store)

```python
# osbot_fast_api/services/registry/Fast_API__Service__Registry.py

from typing                                                                     import Type
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                  import type_safe
from osbot_fast_api.services.schemas.registry.Fast_API__Service__Registry__Client__Config import Fast_API__Service__Registry__Client__Config
from osbot_fast_api.services.schemas.registry.collections.Dict__Fast_API__Service__Configs_By_Type import Dict__Fast_API__Service__Configs_By_Type


class Fast_API__Service__Registry(Type_Safe):                                   # Config store keyed by client type
    configs : Dict__Fast_API__Service__Configs_By_Type                          # Type_Safe auto-creates this

    @type_safe
    def register(self                                                      ,    # Register config for a client type
                 client_type : type                                        ,
                 config      : Fast_API__Service__Registry__Client__Config
            ) -> None:
        self.configs[client_type] = config

    def config(self, client_type: type) -> Fast_API__Service__Registry__Client__Config:
        if client_type not in self.configs:
            return None
        return self.configs[client_type]

    def is_registered(self, client_type: type) -> bool:
        return client_type in self.configs

    def clear(self) -> None:
        self.configs.clear()


fast_api__service__registry = Fast_API__Service__Registry()                     # Singleton instance
```

#### Dict__Fast_API__Service__Configs_By_Type (Collection)

```python
# osbot_fast_api/services/schemas/registry/collections/Dict__Fast_API__Service__Configs_By_Type.py

from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict                     import Type_Safe__Dict
from osbot_fast_api.services.schemas.registry.Fast_API__Service__Registry__Client__Config import Fast_API__Service__Registry__Client__Config


class Dict__Fast_API__Service__Configs_By_Type(Type_Safe__Dict):                # Maps client type → config
    expected_key_type   = type
    expected_value_type = Fast_API__Service__Registry__Client__Config
```

#### Fast_API__Client__Requests (Generic Transport)

```python
# osbot_fast_api/services/registry/Fast_API__Client__Requests.py

from typing                                                                     import Type, Any, Dict, Optional
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.decorators.methods.cache_on_self                               import cache_on_self
from starlette.testclient                                                       import TestClient
from osbot_fast_api.services.registry.Fast_API__Service__Registry               import fast_api__service__registry
from osbot_fast_api.services.schemas.registry.Fast_API__Service__Registry__Client__Config import Fast_API__Service__Registry__Client__Config
from osbot_fast_api.services.schemas.registry.enums.Enum__Fast_API__Service__Registry__Client__Mode import Enum__Fast_API__Service__Registry__Client__Mode
import requests


class Fast_API__Client__Requests(Type_Safe):
    service_type : Type = None                                                  # Subclass sets this to client type

    @cache_on_self
    def config(self) -> Fast_API__Service__Registry__Client__Config:            # Cached config lookup
        config = fast_api__service__registry.config(self.service_type)
        if config is None:
            raise ValueError(f"{self.service_type.__name__} not registered in service registry")
        return config

    @cache_on_self
    def test_client(self):                                                      # TestClient for IN_MEMORY mode
        if self.config().fast_api_app is None:
            raise ValueError("IN_MEMORY mode requires fast_api_app in config")
        return TestClient(self.config().fast_api_app)

    @cache_on_self
    def session(self):                                                          # requests.Session for REMOTE mode
        session = requests.Session()
        if self.config().api_key_value:
            session.headers['Authorization'] = f'Bearer {self.config().api_key_value}'
        return session

    def execute(self, method  : str                ,                            # HTTP method (GET, POST, etc)
                      path    : str                ,                            # Endpoint path
                      body    : Any          = None,                            # Request body
                      headers : Optional[Dict] = None                           # Additional headers
               ):                                                               # Execute request based on mode
        request_headers = {**self.auth_headers(), **(headers or {})}

        if self.config().mode == Enum__Fast_API__Service__Registry__Client__Mode.IN_MEMORY:
            return self.execute_in_memory(method, path, body, request_headers)
        elif self.config().mode == Enum__Fast_API__Service__Registry__Client__Mode.REMOTE:
            return self.execute_remote(method, path, body, request_headers)
        else:
            raise ValueError("Client mode not configured")

    def execute_in_memory(self, method: str, path: str, body: Any, headers: Dict):
        method_func = getattr(self.test_client(), method.lower())
        if body:
            if type(body) is bytes:
                headers["Content-Type"] = "application/octet-stream"
                return method_func(path, data=body, headers=headers)
            else:
                return method_func(path, json=body, headers=headers)
        return method_func(path, headers=headers)

    def execute_remote(self, method: str, path: str, body: Any, headers: Dict):
        url = f"{self.config().base_url}{path}"
        method_func = getattr(self.session(), method.lower())
        if body:
            if type(body) is bytes:
                headers["Content-Type"] = "application/octet-stream"
                return method_func(url, data=body, headers=headers)
            else:
                return method_func(url, json=body, headers=headers)
        return method_func(url, headers=headers)

    def auth_headers(self) -> Dict[str, str]:                                   # Get auth headers from config
        headers = {}
        if self.config().api_key_name and self.config().api_key_value:
            headers[str(self.config().api_key_name)] = str(self.config().api_key_value)
        return headers
```

**Note**: `config()` is now a method with `@cache_on_self`, not a property. This ensures the registry lookup happens once per `Fast_API__Client__Requests` instance, not on every access.

#### Cache__Service__Client__Requests (Domain Extension)

```python
# mgraph_ai_service_cache_client/client/Cache__Service__Client__Requests.py

from typing                                                           import Type
from osbot_fast_api.services.registry.Fast_API__Client__Requests      import Fast_API__Client__Requests


class Cache__Service__Client__Requests(Fast_API__Client__Requests):
    pass  # service_type set at runtime by Cache__Service__Client
```

#### Cache__Service__Client (Stateless Domain Facade)

```python
# mgraph_ai_service_cache_client/client/Cache__Service__Client.py

from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.decorators.methods.cache_on_self                               import cache_on_self
from mgraph_ai_service_cache_client.client.Cache__Service__Client__Requests     import Cache__Service__Client__Requests


class Cache__Service__Client(Type_Safe):                                        # Stateless facade

    @cache_on_self
    def requests(self) -> Cache__Service__Client__Requests:                     # Transport layer
        requests = Cache__Service__Client__Requests()
        requests.service_type = Cache__Service__Client                          # Self-reference for registry lookup
        return requests

    def health(self) -> bool:                                                   # Health check
        try:
            result = self.info().health()
            return result.get('status') == 'ok'
        except:
            return False

    # ───────────────────────────────────────────────────────────────────────────
    # Domain Methods - Pass requests(), not self
    # ───────────────────────────────────────────────────────────────────────────

    @cache_on_self
    def store(self):
        from mgraph_ai_service_cache_client.client.store.Service__Client__File__Store import Service__Client__File__Store
        return Service__Client__File__Store(requests=self.requests())

    @cache_on_self
    def retrieve(self):
        from mgraph_ai_service_cache_client.client.retrieve.Service__Client__File__Retrieve import Service__Client__File__Retrieve
        return Service__Client__File__Retrieve(requests=self.requests())

    @cache_on_self
    def info(self):
        from mgraph_ai_service_cache_client.client.info.Service__Client__Info import Service__Client__Info
        return Service__Client__Info(requests=self.requests())

    @cache_on_self
    def exists(self):
        from mgraph_ai_service_cache_client.client.exists.Service__Client__File__Exists import Service__Client__File__Exists
        return Service__Client__File__Exists(requests=self.requests())

    @cache_on_self
    def delete(self):
        from mgraph_ai_service_cache_client.client.delete.Service__Client__File__Delete import Service__Client__File__Delete
        return Service__Client__File__Delete(requests=self.requests())

    @cache_on_self
    def namespace(self):
        from mgraph_ai_service_cache_client.client.namespace.Service__Client__Namespace import Service__Client__Namespace
        return Service__Client__Namespace(requests=self.requests())

    @cache_on_self
    def namespaces(self):
        from mgraph_ai_service_cache_client.client.namespaces.Service__Client__Namespaces import Service__Client__Namespaces
        return Service__Client__Namespaces(requests=self.requests())
```

**Key change**: Domain operation classes receive `requests=self.requests()`, not `_client=self`. This breaks circular dependencies.

#### Service__Client__File__Store (Domain Operation - Example)

```python
# mgraph_ai_service_cache_client/client/store/Service__Client__File__Store.py

from osbot_utils.type_safe.Type_Safe                                        import Type_Safe
from mgraph_ai_service_cache_client.client.Cache__Service__Client__Requests import Cache__Service__Client__Requests


class Service__Client__File__Store(Type_Safe):
    requests : Cache__Service__Client__Requests                             # Only needs requests, not full client

    def store__json__cache_key(self, namespace, strategy, cache_key, body, file_id, json_field_path):
        path = f"/cache/{namespace}/store"
        payload = {
            "strategy"       : strategy       ,
            "cache_key"      : cache_key      ,
            "body"           : body           ,
            "file_id"        : file_id        ,
            "json_field_path": json_field_path,
        }
        result = self.requests.execute("POST", path, body=payload)
        # ... process result
        return result
```

#### Registration Helper (Simple Function)

```python
# mgraph_ai_service_cache/registration/register_cache_service.py

from osbot_fast_api.services.registry.Fast_API__Service__Registry                               import fast_api__service__registry
from osbot_fast_api.services.schemas.registry.Fast_API__Service__Registry__Client__Config       import Fast_API__Service__Registry__Client__Config
from osbot_fast_api.services.schemas.registry.enums.Enum__Fast_API__Service__Registry__Client__Mode import Enum__Fast_API__Service__Registry__Client__Mode
from mgraph_ai_service_cache.fast_api.Cache_Service__Fast_API                                   import Cache_Service__Fast_API
from mgraph_ai_service_cache_client.client.Cache__Service__Client                               import Cache__Service__Client


def register_cache_service() -> None:
    """Register cache service config for IN_MEMORY mode."""
    
    # Create FastAPI app (server-side)
    fast_api = Cache_Service__Fast_API().setup()
    
    # Create config
    config = Fast_API__Service__Registry__Client__Config(
        mode         = Enum__Fast_API__Service__Registry__Client__Mode.IN_MEMORY,
        fast_api_app = fast_api.app()
    )
    
    # Register config keyed by client type
    fast_api__service__registry.register(Cache__Service__Client, config)
```

### 2.4 Config Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Registration Time                                    │
│                                                                              │
│   register_cache_service()                                                   │
│       │                                                                      │
│       ├── Creates Fast_API__Service__Registry__Client__Config                │
│       │       ├── mode = IN_MEMORY                                           │
│       │       └── fast_api_app = <FastAPI instance>                          │
│       │                                                                      │
│       └── fast_api__service__registry.register(Cache__Service__Client, config)│
│               │                                                              │
│               └── registry.configs[Cache__Service__Client] = config          │
└──────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Request Time                                        │
│                                                                              │
│   client = Cache__Service__Client()                    # Stateless facade    │
│   client.store().store__json__cache_key(...)                                 │
│       │                                                                      │
│       ├── client.requests()                            # Creates Requests    │
│       │       └── requests.service_type = Cache__Service__Client             │
│       │                                                                      │
│       └── Service__Client__File__Store(requests=...).store__json__cache_key()│
│               │                                                              │
│               └── requests.execute("POST", path, body)                       │
│                       │                                                      │
│                       ├── requests.config()            # Cached lookup       │
│                       │       └── registry.config(Cache__Service__Client)    │
│                       │                                                      │
│                       └── if config.mode == IN_MEMORY:                       │
│                               └── TestClient(config.fast_api_app).post(...)  │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 3: Migration Guide

### 3.1 Files to Delete

| Package | File | Reason |
|---------|------|--------|
| `mgraph_ai_service_cache` | `Cache__Service__In_Memory.py` | Replaced by registration function |
| `mgraph_ai_service_cache_client` | `Cache__Service__Fast_API__Client.py` | Merged into `Cache__Service__Client` |
| `mgraph_ai_service_cache_client` | `Cache__Service__Fast_API__Client__Config.py` | Use registry config |
| `mgraph_ai_service_cache_client` | `Cache__Service__Registry__Client.py` | Merged into `Cache__Service__Client` |

### 3.2 Files to Create

| Package | File | Purpose |
|---------|------|---------|
| `osbot_fast_api` | `Fast_API__Client__Requests.py` | Generic transport |
| `osbot_fast_api` | `Dict__Fast_API__Service__Configs_By_Type.py` | Collection for config storage |
| `mgraph_ai_service_cache_client` | `Cache__Service__Client.py` | Unified domain client |
| `mgraph_ai_service_cache_client` | `Cache__Service__Client__Requests.py` | Domain-specific requests |
| `mgraph_ai_service_cache` | `registration/register_cache_service.py` | Registration helper |

### 3.3 Files to Modify

| Package | File | Changes |
|---------|------|---------|
| `osbot_fast_api` | `Fast_API__Service__Registry.py` | Change to store configs, not instances |
| All domain operation files | `Service__Client__File__Store.py`, etc. | Change `_client` to `requests` |

### 3.4 Migration Order

1. **osbot_fast_api**: Update `Fast_API__Service__Registry.py` to store configs
2. **osbot_fast_api**: Add `Dict__Fast_API__Service__Configs_By_Type.py`
3. **osbot_fast_api**: Add `Fast_API__Client__Requests.py`
4. **mgraph_ai_service_cache_client**: Create `Cache__Service__Client.py` and `Cache__Service__Client__Requests.py`
5. **mgraph_ai_service_cache_client**: Update domain operation files (`_client` → `requests`)
6. **mgraph_ai_service_cache**: Create `registration/register_cache_service.py`
7. **mgraph_ai_service_cache**: Delete `Cache__Service__In_Memory.py`
8. **mgraph_ai_service_cache_client**: Delete old client files
9. **Update tests** to use new registration pattern

---

## Part 4: Usage Patterns

### 4.1 Test Setup (IN_MEMORY Mode)

```python
from mgraph_ai_service_cache.registration.register_cache_service  import register_cache_service
from mgraph_ai_service_cache_client.client.Cache__Service__Client import Cache__Service__Client


class test_Something(TestCase):

    @classmethod
    def setUpClass(cls):
        register_cache_service()                            # Registers config in global registry

    def test__cache_operations(self):
        client = Cache__Service__Client()                   # Stateless - gets config from registry
        result = client.store().store__json__cache_key(...)
        assert result is not None
```

### 4.2 Production Setup (REMOTE Mode)

```python
from osbot_fast_api.services.registry.Fast_API__Service__Registry               import fast_api__service__registry
from osbot_fast_api.services.schemas.registry.Fast_API__Service__Registry__Client__Config import Fast_API__Service__Registry__Client__Config
from osbot_fast_api.services.schemas.registry.enums.Enum__Fast_API__Service__Registry__Client__Mode import Enum__Fast_API__Service__Registry__Client__Mode
from mgraph_ai_service_cache_client.client.Cache__Service__Client               import Cache__Service__Client


def setup_production_registry():
    config = Fast_API__Service__Registry__Client__Config(
        mode          = Enum__Fast_API__Service__Registry__Client__Mode.REMOTE,
        base_url      = "https://cache.prod.example.com",
        api_key_name  = "X-API-KEY",
        api_key_value = os.environ["CACHE_API_KEY"]
    )
    
    fast_api__service__registry.register(Cache__Service__Client, config)
```

### 4.3 Service Consumer Pattern

```python
# Any service that needs cache
class Html_Graph__Service(Type_Safe):
    
    def process(self, data):
        # Client is stateless - just create it
        client = Cache__Service__Client()
        
        # Use cache transparently - doesn't know/care about IN_MEMORY vs REMOTE
        cached = client.retrieve().retrieve__cache_id(...)
        if cached:
            return cached
        
        # ... process and store
        client.store().store__json__cache_key(...)
```

### 4.4 Multiple Registries (Test Isolation)

```python
from osbot_fast_api.services.registry.Fast_API__Service__Registry import Fast_API__Service__Registry


class test_Isolated(TestCase):

    def setUp(self):
        self.registry = Fast_API__Service__Registry()       # Fresh registry per test
        # Register with isolated registry instead of global
        config = Fast_API__Service__Registry__Client__Config(...)
        self.registry.register(Cache__Service__Client, config)

    def tearDown(self):
        self.registry.clear()
```

---

## Part 5: Benefits

### 5.1 Reduced Complexity

| Before | After |
|--------|-------|
| 3+ classes per service client | 1 class per service client |
| Duplicated transport logic | Shared `Fast_API__Client__Requests` |
| Duplicated config schemas | Single `Fast_API__Service__Registry__Client__Config` |
| Wrapper classes (`__In_Memory`, `__Registry__Client`) | Simple registration functions |
| Registry stores instances | Registry stores configs (simpler) |
| Circular dependencies (`_client`) | Clean dependencies (`requests`) |

### 5.2 Clear Ownership

- **osbot_fast_api**: Owns transport, registry, base classes, config schema
- **Service Client packages**: Own domain methods only (stateless facades)
- **Service packages**: Own registration helpers for IN_MEMORY mode

### 5.3 Testability

- No mocks needed — IN_MEMORY mode uses real FastAPI app
- ~100ms startup time for full service stack
- Same code paths in tests and production
- Easy test isolation with fresh registry instances

### 5.4 Stateless Clients

Clients are now stateless facades:
```python
client = Cache__Service__Client()   # No config needed
client.store().store__json__cache_key(...)
```

Config lives in registry, not in client instance. This means:
- Clients can be created anywhere, anytime
- No need to pass client instances around
- No risk of stale config

### 5.5 Extensibility

Adding a new service client:

```python
# 1. Create requests subclass (in client package)
class New__Service__Client__Requests(Fast_API__Client__Requests):
    pass

# 2. Create client facade (in client package)
class New__Service__Client(Type_Safe):
    
    @cache_on_self
    def requests(self):
        requests = New__Service__Client__Requests()
        requests.service_type = New__Service__Client
        return requests
    
    @cache_on_self
    def do_something(self):
        return New__Service__Client__Do_Something(requests=self.requests())

# 3. Create registration helper (in service package)
def register_new_service():
    fast_api = New_Service__Fast_API().setup()
    config = Fast_API__Service__Registry__Client__Config(
        mode         = IN_MEMORY,
        fast_api_app = fast_api.app()
    )
    fast_api__service__registry.register(New__Service__Client, config)
```

---

## Part 6: Open Questions

1. **Global vs instance registry**: Current design uses global singleton. Should we support per-application registries?

2. **Error handling**: Should transport raise exceptions or return error results?

3. **Async support**: Should `Fast_API__Client__Requests` support async execution?

4. **Config validation**: Should registry validate config on registration (e.g., IN_MEMORY requires fast_api_app)?

---

## Appendix A: Class Renaming Summary

| Old Name | New Name |
|----------|----------|
| `Cache__Service__Fast_API__Client` | `Cache__Service__Client` |
| `Cache__Service__Registry__Client` | `Cache__Service__Client` |
| `Cache__Service__Fast_API__Client__Config` | (deleted - use registry config) |
| `Cache__Service__Fast_API__Client__Requests` | `Cache__Service__Client__Requests` |
| `Html_Graph__Service__Fast_API__Client` | `Html_Graph__Service__Client` |
| `LLM__Service__Fast_API__Client` | `LLM__Service__Client` |

## Appendix B: Package Dependencies (Unchanged)

```
┌─────────────────────────────────────┐
│       osbot_fast_api                │  ◄── Infrastructure (no service dependencies)
└─────────────────────────────────────┘
                ▲
                │
┌───────────────┴─────────────────────┐
│  mgraph_ai_service_cache_client     │  ◄── Light (schemas + client facade)
└─────────────────────────────────────┘
                ▲
                │
┌───────────────┴─────────────────────┐
│  mgraph_ai_service_cache            │  ◄── Heavy (FastAPI + business logic + registration)
└─────────────────────────────────────┘
```

This dependency direction is **unchanged** — the architecture works within existing constraints.

## Appendix C: Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Registry stores configs, not instances | Clients become stateless; simpler mental model |
| `config()` is method with `@cache_on_self`, not property | Avoids repeated registry lookups |
| Domain operations receive `requests`, not `_client` | Breaks circular dependencies |
| Registration is a function, not a class | No state needed; just wiring |
| Client type is key for config lookup | Type is stable identifier; enables stateless clients |