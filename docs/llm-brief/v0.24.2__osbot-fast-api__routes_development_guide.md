# OSBot-Fast-API - Routes Development Guide

**Purpose**: Guide for LLMs assisting with adding new routes to existing OSBot Fast_API services  
**Scope**: Route implementation, Type_Safe integration, and testing patterns  
**Prerequisites**: This guide assumes the LLM has access to Type_Safe documentation (v3.1.1)
**version** v0.24.2 (15 Sep 2025)

## Quick Reference

When adding routes to a Fast_API service:
1. Create a new `Routes__[Domain]` class inheriting from `Fast_API__Routes`
2. Use Type_Safe schemas for all request/response models (NEVER Pydantic)
3. Follow naming conventions for automatic path generation
4. Implement `setup_routes()` to register endpoints
5. Write comprehensive tests using shared test infrastructure

## Core Architecture

### Fast_API Service Structure

```
Service (e.g., mgraph_ai_service_cache/)
├── fast_api/
│   ├── Service__Fast_API.py         # Main service class
│   ├── lambda_handler.py            # AWS Lambda entry
│   └── routes/
│       ├── Routes__Info.py          # Service info endpoints
│       ├── Routes__Cache.py         # Domain routes
│       └── Routes__[YourDomain].py  # Your new routes
├── schemas/
│   └── [domain]/
│       └── Schema__[YourModel].py   # Type_Safe models
└── service/
    └── [domain]/
        └── [YourDomain]__Service.py # Business logic
```

## Part 1: Creating Route Classes

### Basic Route Class Structure

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing import Dict, List, Optional, Literal

TAG__ROUTES_YOUR_DOMAIN = 'your-domain'                                  # URL prefix
ROUTES_PATHS__YOUR_DOMAIN = [                                           # Document all paths
    f'/{TAG__ROUTES_YOUR_DOMAIN}/list-items',
    f'/{TAG__ROUTES_YOUR_DOMAIN}/get-item/by-id/{{item_id}}',
    f'/{TAG__ROUTES_YOUR_DOMAIN}/create-item'
]

class Routes__Your_Domain(Fast_API__Routes):
    tag : str = TAG__ROUTES_YOUR_DOMAIN                                 # Creates /your-domain prefix
        
    your_service : Your_Domain__Service                                 # Type_Safe will call Your_Domain__Service() and assign it here
    
    def list_items(self, limit     : int = 10        ,                  # GET /your-domain/list-items
                         category : Optional[str] = None
                   ) -> List[Schema__Item]:
        return self.your_service.get_items(limit=limit, category=category)
    
    def get_item__by_id__item_id(self, item_id: Safe_Id                 # GET /your-domain/get-item/by-id/{item_id}
                                 ) -> Schema__Item:
        result = self.your_service.get_by_id(item_id)
        if result is None:
            raise HTTPException(status_code=404, detail="Item not found")
        return result
    
    def create_item(self, item: Schema__Item__Create                    # POST /your-domain/create-item
                    ) -> Schema__Item__Response:
        return self.your_service.create(item)
    
    def setup_routes(self):                                             # REQUIRED - Register all routes
        self.add_route_get(self.list_items)
        self.add_route_get(self.get_item__by_id__item_id)
        self.add_route_post(self.create_item)
        return self
```

### Path Generation Rules

Method names automatically generate REST paths:

| Method Name | Generated Path | HTTP Method |
|------------|---------------|-------------|
| `list_items()` | `/list-items` | GET (via add_route_get) |
| `get_item__by__id(id: str)` | `/get-item/by/{id}` | GET |
| `create_item(item: Schema)` | `/create-item` | POST (via add_route_post) |
| `update_item__id(id: str, item: Schema)` | `/update-item/{id}` | PUT (via add_route_put) |
| `delete_item__id(id: str)` | `/delete-item/{id}` | DELETE (via add_route_delete) |

**Naming Rules**:
- Single underscore `_` becomes hyphen `-`
- Double underscore `__` separates path segments and parameters
- Parameters after `__` become `{param}` in path
- Use descriptive names that make API self-documenting

## Part 2: Type_Safe Schema Integration

### Request/Response Schemas

**CRITICAL**: NEVER use Pydantic models. Always use Type_Safe classes:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid
from typing import List, Dict, Optional, Literal
from enum import Enum

# Status enum
class Enum__Item__Status(str, Enum):
    PENDING   = "pending"
    ACTIVE    = "active"
    COMPLETED = "completed"

# Request schema
class Schema__Item__Create(Type_Safe):
    name        : Safe_Str__Display_Name                                # User-facing name
    description : Safe_Str__Text                                        # Longer text
    category    : Safe_Str__Key                                         # Structured key
    tags        : List[Safe_Str__Tag] = []                             # Auto-initializes
    priority    : Literal["low", "medium", "high"] = "medium"          # Quick enum
    metadata    : Dict[Safe_Str__Key, Safe_Str__Text] = {}            # Type-safe dict

# Response schema with auto-generated fields
class Schema__Item__Response(Type_Safe):
    id          : Random_Guid                                          # Auto-generates on creation
    name        : Safe_Str__Display_Name
    status      : Enum__Item__Status = Enum__Item__Status.PENDING
    created_at  : Timestamp_Now                                        # Auto-captures timestamp
    metadata    : Dict[Safe_Str__Key, Safe_Str__Text]
```

### Using Type_Safe in Routes

Fast_API automatically converts between Type_Safe and JSON:

```python
def create_item(self, request: Schema__Item__Create                    # Type_Safe in
                ) -> Schema__Item__Response:                           # Type_Safe out
    # request is already Type_Safe with full validation
    # No manual conversion needed!
    
    item_id = Random_Guid()
    result = self.your_service.store(
        item_id = item_id,
        data    = request                                              # Pass Type_Safe directly
    )
    
    return Schema__Item__Response(
        id         = item_id,
        name       = request.name,
        status     = Enum__Item__Status.ACTIVE,
        created_at = Timestamp_Now(),                                  # Auto-generates
        metadata   = request.metadata
    )
```

## Part 3: Common Route Patterns

### Pattern 1: Query Parameters with Defaults

```python
def list_items(self, limit      : int = 10                ,            # Query params with defaults
                     offset     : int = 0                  ,
                     sort_by    : Literal["name", "date"] = "date",
                     descending : bool = True
               ) -> Dict[str, Any]:
    # GET /your-domain/list-items?limit=10&offset=0&sort_by=date&descending=true
    items = self.your_service.list(
        limit      = limit,
        offset     = offset,
        sort_by    = sort_by,
        descending = descending
    )
    
    return {
        "items": items,
        "total": len(items),
        "limit": limit,
        "offset": offset
    }
```

### Pattern 2: Different Response Types

```python
from fastapi import Response
import json

def retrieve__string__by_id__id(self, id: Safe_Id) -> str:            # Return plain text
    data = self.your_service.get(id)
    if data is None:
        return Response(content="Not found", status_code=404)
    return Response(content=data, media_type="text/plain")

def retrieve__json__by_id__id(self, id: Safe_Id) -> Dict[str, Any]:   # Return JSON
    data = self.your_service.get(id)
    if data is None:
        return {"status": "not_found"}
    return {"status": "success", "data": data}

def retrieve__binary__by_id__id(self, id: Safe_Id):                   # Return binary
    data = self.your_service.get_binary(id)
    if data is None:
        return Response(content="Not found", status_code=404)
    return Response(content=data, media_type="application/octet-stream")
```

### Pattern 3: Request Body Access

For raw body access (e.g., binary data), use the BodyReaderMiddleware pattern:

```python
from fastapi import Request

def store__binary__namespace(self, request   : Request    ,           # Access raw body
                                   namespace : Safe_Id = None
                             ) -> Schema__Store__Response:
    body = request.state.body                                         # Raw bytes from middleware
    
    # Check headers
    content_encoding = request.headers.get('content-encoding')
    if content_encoding == 'gzip':
        import gzip
        body = gzip.decompress(body)
    
    result = self.your_service.store_binary(
        data      = body,
        namespace = namespace
    )
    
    return Schema__Store__Response(
        id   = result.id,
        size = len(body)
    )
```

### Pattern 4: Error Handling

```python
from fastapi import HTTPException

def get_item__id(self, id: Safe_Id) -> Schema__Item:
    try:
        result = self.your_service.get(id)
        if result is None:
            raise HTTPException(
                status_code = 404,
                detail      = f"Item {id} not found"
            )
        return result
        
    except ValueError as e:
        raise HTTPException(
            status_code = 400,
            detail      = str(e)
        )
    except Exception as e:
        # Log the error
        logger.error(f"Unexpected error: {str(e)}")
        raise HTTPException(
            status_code = 500,
            detail      = "Internal server error"
        )
```

## Part 4: Registering Routes

### In Service__Fast_API

Add your routes to the main service class:

```python
from osbot_fast_api_serverless.fast_api.Serverless__Fast_API import Serverless__Fast_API
from your_service.fast_api.routes.Routes__Your_Domain import Routes__Your_Domain

class Service__Fast_API(Serverless__Fast_API):
    
    def setup_routes(self):
        self.add_routes(Routes__Info)                                 # Existing routes
        self.add_routes(Routes__Your_Domain)                          # Your new routes
        return self
```

## Part 5: Testing Routes

### Test File Structure

Mirror the source structure:

```python
# Source: your_service/fast_api/routes/Routes__Your_Domain.py
# Test:   tests/unit/fast_api/routes/test_Routes__Your_Domain.py
```

### Basic Route Test Structure

```python
from unittest import TestCase
from osbot_utils.utils.Objects import base_classes
from osbot_utils.testing.__ import __, __SKIP__

class test_Routes__Your_Domain(TestCase):
    
    @classmethod
    def setUpClass(cls):                                              # Expensive setup ONCE
        cls.routes = Routes__Your_Domain()
        cls.routes.your_service = Mock_Your_Service()                 # Use real service when possible
    
    def test__init__(self):                                          # Test initialization
        with self.routes as _:
            assert type(_) is Routes__Your_Domain
            assert base_classes(_) == [Fast_API__Routes, Type_Safe, object]
            assert _.tag == 'your-domain'
    
    def test_list_items(self):                                       # Test route method directly
        with self.routes.list_items(limit=5) as result:
            assert type(result) is list
            assert len(result) <= 5
            if result:
                assert type(result[0]) is Schema__Item
    
    def test_get_item__by_id__item_id(self):                        # Test with parameters
        test_id = Safe_Id("TEST-123")
        with self.routes.get_item__by_id__item_id(test_id) as result:
            assert type(result) is Schema__Item
            assert result.id == test_id
    
    def test_get_item__by_id__item_id__not_found(self):            # Test error case
        with pytest.raises(HTTPException) as exc_info:
            self.routes.get_item__by_id__item_id(Safe_Id("INVALID"))
        assert exc_info.value.status_code == 404
        assert "not found" in exc_info.value.detail.lower()
```

### Client-Based Integration Tests

```python
from tests.unit.Service__Fast_API__Test_Objs import setup__service_fast_api_test_objs

class test_Routes__Your_Domain__client(TestCase):
    
    @classmethod
    def setUpClass(cls):                                             # Reuse shared FastAPI app
        with setup__service_fast_api_test_objs() as _:
            cls.client = _.fast_api__client
            cls.client.headers[TEST_API_KEY__NAME] = TEST_API_KEY__VALUE
    
    def test__list_items(self):                                     # Test via HTTP
        response = self.client.get('/your-domain/list-items?limit=5')
        assert response.status_code == 200
        
        result = response.json()
        assert 'items' in result
        assert len(result['items']) <= 5
    
    def test__create_item(self):                                    # Test POST with Type_Safe
        request_data = {
            "name": "Test Item",
            "description": "Test description",
            "category": "test-category",
            "tags": ["tag1", "tag2"]
        }
        
        response = self.client.post('/your-domain/create-item', json=request_data)
        assert response.status_code == 200
        
        result = response.json()
        assert result['name'] == "Test Item"
        assert result['status'] == "pending"
        assert 'id' in result                                       # Auto-generated
        assert 'created_at' in result                               # Auto-generated
    
    def test__validation_error(self):                               # Test error responses
        response = self.client.post('/your-domain/create-item', json={})
        assert response.status_code == 422                          # Validation error
        
        error = response.json()
        assert 'detail' in error
        assert any('name' in str(e) for e in error['detail'])      # Missing required field
```

### Testing with .obj() Pattern

```python
def test__create_item__complete_validation(self):
    with Schema__Item__Create() as request:
        request.name = "Test Item"
        request.category = "test"
        
        with self.routes.create_item(request) as response:
            # Use .obj() for comprehensive comparison
            assert response.obj() == __(
                id         = __SKIP__,                              # Auto-generated
                name       = "Test Item",
                status     = "pending",
                created_at = __SKIP__,                              # Timestamp
                metadata   = {}
            )
```

## Part 6: Common Patterns and Best Practices

### Visual Alignment

Follow Type_Safe alignment patterns:

```python
def process_item(self, item_id     : Safe_Id              ,         # Align parameters
                       action      : Literal["approve", "reject"],
                       comment     : Optional[Safe_Str__Text] = None
                 ) -> Schema__Process__Response:                    # Return type aligns
    # Dictionary creation with alignment
    result = dict(item_id = item_id ,
                  action  = action  ,
                  comment = comment )
    
    # Assertions with alignment
    assert type(item_id) is Safe_Id
    assert action        in ["approve", "reject"]
    assert comment       is None or type(comment) is Safe_Str__Text
```

### Service Dependencies

As long as your dependencies don't need init params, you can just declare them in the Routes__* class

```python
class Routes__Your_Domain(Fast_API__Routes):
    tag = 'your-domain'
    
    # Declare service dependencies
    your_service   : Your_Domain__Service                                   # Type safe will do there
    cache_service  : Cache__Service
    storage_service: Storage__Service
    
```

### Strategy Pattern for Complex Operations

```python
def store__strategy__namespace(self, data       : Schema__Data,
                                     strategy   : Literal["direct", "cached", "distributed"] = "cached",
                                     namespace : Safe_Id = None
                               ) -> Schema__Response:
    strategies = {
        "direct"     : self._store_direct,
        "cached"     : self._store_cached,
        "distributed": self._store_distributed
    }
    
    handler = strategies.get(strategy)
    if not handler:
        raise HTTPException(400, f"Unknown strategy: {strategy}")
    
    return handler(data, namespace)
```

## Part 7: AWS Lambda Considerations

### Lambda Handler Integration

Routes work seamlessly with Lambda:

```python
# lambda_handler.py
from your_service.fast_api.Service__Fast_API import Service__Fast_API

with Service__Fast_API() as _:
    _.setup()
    handler = _.handler()
    app     = _.app()

def run(event, context=None):
    return handler(event, context)
```

### Cold Start Optimization

```python
class Routes__Your_Domain(Fast_API__Routes):
    
    def __init__(self):
        super().__init__()
        # Lazy initialization for Lambda
        self._service = None
    
    @property
    def your_service(self):
        if self._service is None:
            self._service = Your_Domain__Service().setup()
        return self._service
```

## Critical Rules

### ALWAYS:
- Use Type_Safe classes for ALL schemas (NEVER Pydantic)
- Implement `setup_routes()` method
- Follow double underscore naming for path parameters
- Test with shared FastAPI test infrastructure
- Use `.obj()` pattern for comprehensive testing
- Handle None/not found cases explicitly
- Document paths in ROUTES_PATHS__ constant

### NEVER:
- Use Pydantic BaseModel
- Use FastAPI decorators (@app.get, @app.post)
- Create new FastAPI apps in tests (use shared)
- Use raw primitives when Safe types exist
- Skip error handling
- Use docstrings (use inline comments)

## Testing Checklist

- [ ] Test class inherits from TestCase
- [ ] Use setUpClass for expensive setup
- [ ] Test __init__ verifies inheritance chain
- [ ] Test each route method directly
- [ ] Test via client for integration
- [ ] Test error cases (404, 400, 422)
- [ ] Use .obj() with __SKIP__ for dynamic values
- [ ] Verify Type_Safe conversion works
- [ ] Test query parameters with defaults
- [ ] Test different response types if applicable

## Example: Complete Route Implementation

```python
# your_service/fast_api/routes/Routes__Orders.py
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
from fastapi import HTTPException
from typing import List, Optional

TAG__ROUTES_ORDERS = 'orders'
ROUTES_PATHS__ORDERS = [
    f'/{TAG__ROUTES_ORDERS}/list',
    f'/{TAG__ROUTES_ORDERS}/get/by-id/{{order_id}}',
    f'/{TAG__ROUTES_ORDERS}/create',
    f'/{TAG__ROUTES_ORDERS}/update/{{order_id}}',
    f'/{TAG__ROUTES_ORDERS}/delete/{{order_id}}'
]

class Routes__Orders(Fast_API__Routes):
    tag = TAG__ROUTES_ORDERS
    
    order_service: Order__Service
    
    def list(self, status: Optional[Enum__Order__Status] = None,
                   limit : int = 100
            ) -> List[Schema__Order]:
        return self.order_service.list_orders(status=status, limit=limit)
    
    def get__by_id__order_id(self, order_id: Safe_Id) -> Schema__Order:
        order = self.order_service.get(order_id)
        if not order:
            raise HTTPException(404, f"Order {order_id} not found")
        return order
    
    def create(self, order: Schema__Order__Create) -> Schema__Order__Response:
        return self.order_service.create_order(order)
    
    def update__order_id(self, order_id : Safe_Id,
                               updates  : Schema__Order__Update
                        ) -> Schema__Order__Response:
        result = self.order_service.update(order_id, updates)
        if not result:
            raise HTTPException(404, f"Order {order_id} not found")
        return result
    
    def delete__order_id(self, order_id: Safe_Id) -> Dict[str, Any]:
        deleted = self.order_service.delete(order_id)
        return {"deleted": deleted, "order_id": str(order_id)}
    
    def setup_routes(self):
        self.add_route_get(self.list)
        self.add_route_get(self.get__by_id__order_id)
        self.add_route_post(self.create)
        self.add_route_put(self.update__order_id)
        self.add_route_delete(self.delete__order_id)
        return self
```

## Summary

This guide provides the essential patterns for adding routes to Fast_API services. Key points:

1. **Always use Type_Safe** - Never Pydantic models
2. **Follow naming conventions** - Double underscores for path parameters
3. **Implement setup_routes()** - Register all endpoints
4. **Test comprehensively** - Direct methods and client integration
5. **Use shared test infrastructure** - Don't create new FastAPI apps
6. **Handle errors explicitly** - Return proper HTTP status codes
7. **Document paths** - Maintain ROUTES_PATHS__ constants

For Type_Safe details, refer to the companion guides:
- "Type_Safe & Python Formatting Guide for LLMs v3.1.1"
- "Type_Safe Testing Guidance for LLMs v3.1.1"