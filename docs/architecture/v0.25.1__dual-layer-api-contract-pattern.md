# Dual-Layer API Contract Pattern for Service Clients
by Dinis Cruz and ChatGPT Deep Research, 22nd September 2025, v0.25.1 

## Overview

Modern service-oriented architectures often consist of many
microservices or components, each exposing functionality via an API.
Traditionally, the **REST API** itself is treated as the primary
contract between services and their consumers. Changes to the API are
tightly controlled and versioned to avoid breaking clients. However,
this conservative approach can slow down development and complicate
refactoring.

This paper introduces a **dual-layer API contract pattern** that offers
the *best of both worlds*: a stable, developer-friendly **Python client
API** on top of a highly flexible **REST service API**. By splitting the
contract into two layers -- a **Python SDK (client library)** and a
**REST/HTTP interface** -- service developers can iterate on internal
APIs rapidly while presenting a reliable, type-safe interface to
consumers. This approach leverages the OSBot Type_Safe schema system to
ensure strong typing and validation across both layers. The result is
faster evolution of services without breaking clients, improved
developer experience, and shared testing benefits.

## Challenges with Traditional API Contracts

In a microservice ecosystem, services often call each other or are
consumed by client applications. The conventional wisdom is to treat the
service's REST API as the fixed contract. Any change risks breaking
clients, so teams resort to versioned endpoints (`v1`, `v2`, etc.) or
avoid changes altogether. This model raises several issues:

-   **Rigid Versioning:** Maintaining multiple API versions leads to
    redundant code and complexity. Even minor improvements require
    creating new endpoints or payload versions, and deprecated versions
    must be supported for long periods. This slows down refactoring and
    optimization efforts.
-   **Schema Duplication:** Often the data models (schemas) are defined
    separately in each service and in clients. Developers may end up
    copy-pasting POJOs/DTOs or writing duplicate classes for
    request/response structures in every client
    service[[1]](https://stackoverflow.com/questions/50400384/in-the-microservices-architecture-why-they-say-is-bad-to-share-rest-client-libr#:~:text=I%20would%20say%20,copy%20and%20pasting%20client%20code).
    This duplication increases maintenance effort and risk of
    inconsistencies.
-   **Client Burden:** Without an official client library, each consumer
    must handle HTTP calls, serialization, and validation. Every team
    integrates the API slightly differently, potentially introducing
    errors. Common logic like authentication, retry policies, or data
    formatting is re-implemented in each client.
-   **Inhibited Refactoring:** Fear of breaking external integrators
    means the server team cannot easily change internal implementations
    or improve the API design. Technical debt accumulates as changes are
    deferred or layered on via new endpoints.

In summary, the traditional approach forces a one-size-fits-all contract
at the REST layer, which must serve both as the **external interface**
and the **internal implementation detail**. This often results in
stagnation or excessive workarounds to evolve the API.

## Two-Layer Client Contract Pattern

The proposed solution is to establish **two distinct contracts** for
each service: one at the **Python client layer** and one at the **REST
API layer**. Each service team not only develops the service itself
(with its REST endpoints) but also provides and maintains a **dedicated
Python client library** for that service. Consumers of the service
(especially other internal services written in Python) use this client
library instead of calling the REST API directly.

Under this model, the *Python client library* is the **primary
contract** that client developers rely on, whereas the REST API becomes
an internal, flexible contract between the client library and the
service:

-   **Python Client Library (Stable SDK)** -- A Python package (e.g.
    `mgraph_ai_service_name_client`) that includes all domain
    **schemas** and convenient wrapper methods for every operation the
    service provides. This library offers a strongly-typed, idiomatic
    interface as if calling local code, abstracting away HTTP details.
    It remains backward-compatible as much as possible, meaning its
    public functions and classes change infrequently and carefully.
-   **Service REST API (Flexible Endpoint Layer)** -- The actual HTTP
    endpoints (e.g. FastAPI routes) that the service implements. This
    layer can be optimized for performance, efficiency, and clarity of
    implementation. Because the primary consumers (via the client SDK)
    are under the same development control, the REST API is allowed to
    evolve more freely without strict guarantees of backward
    compatibility. In essence, it becomes a *private implementation
    detail* of the client library, rather than a public contract set in
    stone.

By decoupling the external contract from the internal REST interface, we
gain agility. The service team is free to refactor, rename, split, or
optimize REST endpoints as needed to improve the system, so long as the
**client library is updated accordingly**. Clients using the library
experience a stable API even if under the hood the REST calls or data
formats changed.

### Structure and Ownership

A key principle of this pattern is that **the service team owns both the
service and its client library**. For every service (e.g. a caching
service), there is a corresponding client package (e.g. a `cache_client`
module). The server project depends on the client project for the schema
definitions (shared data models), creating a one-to-one linkage. This
ensures there is a single source of truth for what the data structures
look like. As a result, *anyone developing a new service capability must
update the schema and client in tandem with the server*. This unified
ownership yields better maintenance and usage control:

-   **Synchronized Schema Updates:** When the service introduces a new
    field or changes a data model, the change is made in the shared
    schema (in the client package). The server uses this updated schema
    internally, and the client library automatically reflects the change
    in its next version. There is no chance of forgetting to update
    client-side definitions or mismatches in serialization, since the
    model code is literally the same.
-   **Immediate Client Support:** The service team provides ready-to-use
    client methods for any new API functionality. Consumers don't need
    to write their own HTTP call logic; they just upgrade the client SDK
    and call the new method. This reduces friction in adoption of new
    features.
-   **Testing in Tandem:** Because the client is maintained by the
    service authors, it can be used to test the service endpoints as
    part of the development process. Integration tests for the service
    are written using the client library calls, which mimic real usage.
    This means that whenever the service implementation changes, running
    the client-based test suite will catch any unintended breakage. In
    effect, the client library's test suite doubles as a **regression
    test suite** for the service API. The team gains confidence that if
    all client-level tests pass, consumers will not be impacted by
    internal changes.

Notably, this approach aligns with practices seen in industry: for
example, large cloud providers publish official SDKs for their services
rather than expecting users to hand-craft HTTP calls. The difference
here is that we treat our **internal microservices** with the same
philosophy -- each service has an SDK, and internal consumers use it. As
one expert noted, if all services are maintained by a single team (i.e.
not requiring cross-team coordination), providing a client library is
perfectly sensible and trades some microservice autonomy for ease of
use[[2]](https://softwareengineering.stackexchange.com/questions/408106/calling-microservice-using-rest-or-dedicated-client-jar#:~:text=helps%20enforce%20the%20REST%20API,as%20the%20actual%20API%20boundary).
In our context, the organizational overhead is low (same team), so the
benefits of a shared library outweigh the downsides.

## Python Client Layer -- The Stable Contract

The Python client library for a service is the **face of the service**
for developers. It abstracts the raw REST calls behind clean, Pythonic
functions and classes. This layer is designed to be **type-safe,
intuitive, and as stable as possible** across versions.

Key characteristics of the client layer:

-   **Shared Schema Definitions:** The client package contains all the
    data model classes (schemas) that describe requests and responses
    for the service. These are implemented using the OSBot **Type_Safe**
    framework, which enforces strict type constraints at
    runtime[[3]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Type_Safe%20is%20a%20runtime%20type,money%2C%20URLs%2C%20and%20file%20paths).
    By using Type_Safe classes for schemas, we ensure that objects
    passed to the client or returned from it are validated immediately
    against expected types and ranges. For example, if
    `Schema__CacheEntry` expects a field to be an integer ID, any
    attempt to assign a non-integer will throw an error at assignment
    time (rather than causing a bug deep in execution). This provides
    strong guarantees of correctness on the client side.

-   **Idiomatic API Methods:** The client exposes high-level methods
    corresponding to service operations. For instance, a Cache service
    client might have a method `store_json(data, strategy, namespace)`
    instead of the caller having to construct an HTTP POST request
    manually. Internally, this method will perform the POST to the
    appropriate REST endpoint and handle the response. An example from
    the Cache Service client illustrates this structure, where calling
    `store_json` posts the data to the service and returns the result as
    a Python object or
    dict[[4]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=def%20store_json%28self%2C%20data%2C%20strategy%3D,json%3Ddata%20%29%20return%20response.json).
    The client methods hide details like URLs, HTTP verbs, and payload
    formatting. Consumers just call Python functions with native types
    (e.g. passing a Python dict for JSON data), and the library handles
    conversion to JSON, HTTP communication, and error checking.

-   **Type Safety and Object Conversion:** Because the schemas are
    shared, the client can automatically convert raw JSON responses from
    the service back into Type_Safe objects or other domain-specific
    classes. This means a consumer calling a client method might receive
    a rich Python object (with methods and validations) rather than a
    raw JSON dict. For example, if the service returns a `CacheEntry`
    JSON, the client library could instantiate a `Schema__CacheEntry`
    object from it. The Type_Safe system supports JSON
    serialization/deserialization out of the
    box[[5]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=FastAPI%20automatically%3A%201,Handles%20Enum%20serialization%2Fdeserialization)[[6]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Benefits%20of%20Type_Safe%20over%20Pydantic,in%20security%2A%2A%20via%20Safe%20primitives),
    so implementing this conversion is straightforward. The benefit is
    that client code can work with higher-level objects with methods and
    ensure the data meets the schema, rather than handling untyped JSON.
    It also avoids duplicate model parsing code -- **the same class
    definitions are used for serialization in the server and
    deserialization in the client**, fulfilling the "one model for all
    layers"
    principle[[6]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Benefits%20of%20Type_Safe%20over%20Pydantic,in%20security%2A%2A%20via%20Safe%20primitives).

-   **Backwards Compatibility:** The client library is treated as a
    long-lived contract. Effort is made to avoid breaking changes in the
    client's public API. When the service evolves, the client can often
    be updated in a backward-compatible way (e.g. adding new optional
    parameters, deprecating but not removing methods). If a truly
    breaking change in the service is required, the client can implement
    a shim or translation to preserve the old interface for callers. For
    example, if two REST endpoints are merged into one on the server,
    the client could keep the two old methods and under the hood direct
    both to the new endpoint, composing the request as needed. This is
    analogous to how polyfill or shim libraries allow older code to use
    new behaviors without changes. The goal is that **client
    applications should rarely need to change their code** when the
    service changes -- they just update to a new client library version
    that adapts to the service. In practice, this might involve the
    client library maintaining compatibility code paths for multiple
    server versions if necessary, or releasing a new major version of
    the client with clear migration notes when absolutely unavoidable.

In summary, the Python client layer provides a **user-friendly, stable
API** for the service's functionality. It leverages strong typing and
shared schemas to catch errors early and ensure consistency. By using
the client, developers are insulated from the volatility of the
service's internal API and can trust that if their code works against
version X of the client, it will continue to work with minimal changes
moving forward.

## REST API Layer -- The Flexible Contract

On the other side of the divide is the service's **REST API** (e.g.
FastAPI endpoints). This is the low-level contract which the client
library consumes. In the dual-layer pattern, we intentionally **loosen
the stability requirements** of this layer, granting the service more
freedom to change its HTTP interface for legitimate reasons. Key aspects
of the REST layer in this model include:

-   **Internal Implementation Focus:** We treat the REST endpoints as an
    internal detail of the service module. Their primary consumer is the
    official client library (and by extension the service's own tests).
    Because of this, the service team can modify endpoints to improve
    performance, fix design flaws, or accommodate new features without
    first coordinating a long deprecation cycle with external teams. For
    example, if a single overly broad endpoint is better split into two
    more efficient endpoints, the team can make that change in a new
    server version and update the client library to call the new ones.
    There is less fear of "breaking the world" because external code
    should not be calling the REST API directly, or if it is, it's
    understood to be a volatile interface.

-   **No Strict Versioning of Endpoints:** In this pattern, we avoid
    proliferating multiple coexisting API versions (like
    `/api/v1/resource` vs `/api/v2/resource`). Instead, the service can
    continuously evolve *its single set of endpoints*. If a change is
    incompatible, the old behavior can be handled in the client or
    phased out quickly since the service team controls all official
    consumers. This does not mean chaos -- good API design and
    discipline still apply -- but it means we aren't locked into
    supporting outdated endpoints indefinitely. The focus shifts from
    *avoiding any breaking change* to *managing changes* in a controlled
    way with the help of the client layer.

-   **Optimized for Performance and Simplicity:** Freed from needing to
    serve as a one-size-fits-all interface, the REST API can be designed
    for optimal performance and clarity of purpose. The team can
    introduce specialized endpoints that client methods use to fetch
    exactly the data needed, reducing over-fetching or under-fetching
    scenarios common in generic APIs. For instance, instead of an
    endpoint that returns an entire object when clients often only need
    a small part, the service might offer a lighter endpoint for that
    piece of data. Normally, adding such an endpoint might be weighed
    against the confusion of multiple options for external users; but
    here, the client library can hide those details and present one
    coherent method, calling whichever endpoint is appropriate.
    Similarly, the service can choose payload formats that are efficient
    for transmission and parsing (since the client will adapt them to
    nice Python objects). In our implementation, all data is transferred
    as JSON (or binary when needed), and the schemas defined via
    Type_Safe also inform the OpenAPI documentation. FastAPI with
    Type_Safe integration automatically generates the OpenAPI schema
    from our
    classes[[5]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=FastAPI%20automatically%3A%201,Handles%20Enum%20serialization%2Fdeserialization),
    which helps in understanding the REST interface during development,
    even if it's not directly used by end developers.

-   **Example -- Cache Service API:** As an illustration, consider the
    caching service. At the REST level, it provides endpoints like
    `POST /{namespace}/{strategy}/store/json` to store data and
    `GET /{namespace}/retrieve/{cache_id}` to retrieve data, among
    others[[7]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=Storage%20Operations)[[8]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=Retrieval%20Operations).
    These endpoints are fairly low-level, concerned with things like
    namespace names, strategies, IDs, etc. The Python client wraps these
    in higher-level functions. If the caching service team decides to
    change how retrieval works (say, merging the generic and
    type-specific retrieval endpoints, or changing URL structures for
    clarity), they are free to do so. They would update the client's
    `retrieve` method to call the new endpoint(s). External code calling
    `CacheClient.retrieve_by_hash(hash)` would continue to work after a
    client library update, even if the underlying REST call it makes is
    different. Thus, the REST API can be streamlined or restructured
    over time without directly impacting client code.

It's important to note that **flexibility does not mean instability for
its own sake**. We still design the REST API carefully, and in many
cases we strive for backward compatibility. But the crucial difference
is that we are not beholden to long-term support of every detail at the
REST layer when changes are beneficial. We rely on the client layer as a
buffer to adapt to those changes.

## Shared Schema and Type Safety

A cornerstone of this dual contract approach is the use of **shared
schemas** between the client and server, enabled by the Type_Safe
framework. The philosophy "**Schema as Code**" is applied -- data models
are defined once as Python classes and reused across all layers. This
provides multiple benefits:

-   **Single Source of Truth:** There is no divergence between what the
    server expects/returns and what the client understands. For example,
    if there is a `Schema__User` defining a user object, both the
    FastAPI server and the Python client import this same class
    definition. Changes to `Schema__User` (say adding a field or
    tightening a validation rule) automatically apply in both places.
    This eliminates the class of errors where a client is working with
    an outdated representation of data.

-   **Automatic Validation:** Type_Safe classes perform validation at
    runtime on assignment and method
    calls[[3]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Type_Safe%20is%20a%20runtime%20type,money%2C%20URLs%2C%20and%20file%20paths).
    On the server side, FastAPI with OSBot utilities will convert
    incoming JSON payloads into Type_Safe objects and validate them
    (replacing the need for
    Pydantic)[[9]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=With%20OSBot_Fast_API%27s%20built,FastAPI%20routes%20with%20automatic%20conversion)[[5]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=FastAPI%20automatically%3A%201,Handles%20Enum%20serialization%2Fdeserialization).
    On the client side, any object constructed or data returned can be
    validated similarly. For instance, if the cache client receives JSON
    from the server for a stored item, it can initialize a
    `Schema__Cache__Item` object from that JSON. The Type_Safe class
    will check that all fields conform to the expected types (and even
    value ranges, formats, etc., thanks to Safe_* primitive types).
    This end-to-end validation significantly reduces the likelihood of
    corrupt or unexpected data propagating through the system.

-   **OpenAPI Documentation:** Defining the schemas in code means our
    documentation can be generated automatically. FastAPI uses the
    Type_Safe models to produce an OpenAPI (Swagger) spec for the REST
    API[[5]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=FastAPI%20automatically%3A%201,Handles%20Enum%20serialization%2Fdeserialization).
    This spec can be useful for non-Python clients or for reviewing the
    API. The important point is we don't maintain separate YAML/JSON for
    the API spec -- it is derived from the same source classes. This
    aligns with the principle of **no duplicate model definitions** --
    one model for all layers (client, server,
    documentation)[[6]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Benefits%20of%20Type_Safe%20over%20Pydantic,in%20security%2A%2A%20via%20Safe%20primitives).

-   **Safer Evolution:** When schemas change, Type_Safe will throw
    errors if something is incompatible, which surfaces issues quickly
    during development. For example, if a field's type is changed and
    the server starts sending a slightly different format, the client's
    attempt to parse it into the old schema would fail in tests -- a
    clear indicator to update the client code. This is actually
    advantageous: it forces the team to consciously handle the change in
    the client library (possibly by adjusting the schema class or
    providing conversion logic), rather than silently ignoring it or
    letting it cause random failures in production. In other words, the
    type safety acts as a **contract test** between client and server:
    if the contracts don't match, you find out immediately.

In practice, the Type_Safe framework and the pattern of placing schemas
in the client package has worked well. The **Cache Service** uses
Type_Safe classes for requests and responses (e.g.
`Schema__Cache__Store__Request`, `Schema__Cache__Store__Response`) and
these are used both in the FastAPI route functions and in the cache
client library. Developers define new classes or extend existing ones
when new features are added. The **LLM Service** (large language model
service) is another area where this will be applied: complex request
structures for AI prompts and responses can be defined once and then
both the service and its clients can rely on the exact same definitions
and checks. This greatly simplifies integrating such services, as each
consumer doesn't need to reinvent the data model.

## Testing and Development Workflow

Adopting a two-layer contract pattern also influences how we test and
deploy services. Because the client library and server are developed in
tandem, we leverage the client in various stages of the lifecycle:

-   **Development & Unit Testing:** When adding a new feature to a
    service, the developer typically updates or creates a client method
    for it at the same time. To test the service locally (or in a
    staging environment), the developer can write tests that instantiate
    the client and call the new method, asserting that the response or
    behavior is correct. This feels like testing a normal Python module,
    but under the hood it's exercising the full stack (client
    serialization, HTTP call, server logic, database, etc.). It's
    effectively a lightweight integration test, but because the client
    abstracts the details, tests remain clean and focused on high-level
    behavior. Moreover, the Type_Safe testing approach (as outlined in
    our testing guide) encourages writing tests that mirror the source
    structure and use context managers for
    setup[[10]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=,py)[[11]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=Context%20Manager%20Pattern%20with%20%27_%27).
    In client tests, this means you spin up a test instance of the
    service (often using FastAPI's TestClient) and reuse it for multiple
    tests, which is
    efficient[[12]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=For%20integration%20tests%2C%20especially%20those,for%20the%20entire%20test%20suite)[[13]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=match%20at%20L1027%20,fast_api__app).
    The bottom line is that the client library serves as a convenient
    harness for exercising the service exactly as consumers would.

-   **Continuous Integration (CI):** We include the client library's
    test suite as part of the CI pipeline for the service. Any commit
    that changes the service or client code must pass all tests, which
    include calling the service via the client. This provides immediate
    feedback if an internal change inadvertently breaks the contract
    that the client expects. For example, if a REST endpoint response
    format changes but the client's parsing logic wasn't updated, a test
    will fail. This tight feedback loop guards the stability of the
    client interface.

-   **Cross-Service Testing:** In an environment where multiple services
    use each other's clients, we gain an additional safety net: when
    Service A (consumer) uses Service B's client library, and Service B
    makes a change, integration tests in Service A that use the client
    may fail if something is incompatible. This encourages a practice of
    updating dependencies in a controlled manner and possibly running a
    suite of integration tests for impacted services. Over time, this
    fosters confidence that changes in one service (with an updated
    client) won't blindside another part of the system.

-   **Version Management:** The client library is versioned (just like
    any other Python package). When breaking changes do occur, they are
    reflected in a major version bump of the client, and services that
    depend on it can upgrade on their own schedule. However, because the
    service team controls the timing of releasing a new client and
    deprecating old ones, they can manage transitions gracefully. For
    internal services, we might decide to support only the latest client
    version (since we can coordinate deployments together). In other
    cases, both old and new clients could temporarily work against the
    service (if the service is coded to handle both formats), allowing
    staggered upgrades. This flexibility in deployment is another
    advantage of decoupling the external interface (client API) from the
    internal REST interface.

In essence, the development workflow becomes *client-first*. We design
the client API as the consumption model and ensure the service meets
that, rather than exposing raw endpoints and forcing each consumer to
adapt. This client-driven approach, combined with rigorous testing,
yields more reliable and predictable integrations.

## Benefits Summary

Adopting the dual-layer client contract pattern provides numerous
benefits:

-   **Stable, User-Friendly Interface:** Consumers interact with a
    stable Python API tailored to their needs. They benefit from
    **type-safe classes** and intuitive methods instead of raw HTTP
    calls. This boosts developer productivity and reduces errors since
    the heavy lifting (validation, serialization, etc.) is handled by
    the
    library[[3]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Type_Safe%20is%20a%20runtime%20type,money%2C%20URLs%2C%20and%20file%20paths).

-   **Agile Service Evolution:** Service teams can refactor and improve
    the REST API freely. They are not handcuffed by legacy clients
    because the official client library abstracts those changes.
    Internal improvements (performance tweaks, endpoint restructuring,
    payload changes) can happen with minimal coordination. This
    encourages continuous improvement and cleaner server code over time,
    without the bloat of eternal backward compatibility layers.

-   **Single Source of Truth for Models:** Schemas are defined once and
    reused everywhere, eliminating drift. The approach of using
    Type_Safe models in FastAPI means **no duplicate model definitions**
    are needed for different
    layers[[6]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Benefits%20of%20Type_Safe%20over%20Pydantic,in%20security%2A%2A%20via%20Safe%20primitives).
    It reduces development effort and bugs by having consistent data
    contracts.

-   **Shared Testing and Quality Assurance:** The client library
    effectively doubles as a test suite for the service. By using the
    client in tests (and by the team itself for QA), any discrepancy
    between expected and actual service behavior is caught early. This
    leads to higher quality services and confidence in deployments. It
    also means that the service team is dogfooding their own API via the
    client, which often results in a better design for real-world use
    cases.

-   **Better Separation of Concerns:** Each layer can focus on what it
    does best. The **REST layer** focuses on core functionality,
    efficiency, and stateless operation -- it's the bare-bones
    interface optimized for the machine-to-machine communication. The
    **client layer** focuses on developer experience, offering
    conveniences, handling retries or auth, and presenting data in rich
    forms. This separation makes each layer simpler than trying to have
    one layer serve all purposes.

-   **Reduced Client Code Duplication:** Without an official library,
    multiple services or teams might write similar code to consume a
    given service (e.g. making requests and parsing JSON). This pattern
    centralizes that logic into one maintained client. Bugs in the
    integration code only need to be fixed once (in the client lib)
    rather than in every
    consumer[[14]](https://stackoverflow.com/questions/50400384/in-the-microservices-architecture-why-they-say-is-bad-to-share-rest-client-libr#:~:text=,along%20with%20virtually%20everyone%20else).
    It also lowers the learning curve for new developers -- they only
    need to know how to use the high-level client API, not the
    intricacies of the REST calls.

-   **Organizational Efficiency:** Especially when the same team
    maintains both sides, this model streamlines development. It is
    easier to coordinate changes, since updating the service and its
    client library can be part of the same workflow. In cases where
    separate teams or external users are involved, the client library
    still serves as a contract where changes can be communicated via
    library version updates.

By leveraging this approach, we effectively create a **contract of
convenience and stability (Python SDK)** powered internally by a
**contract of efficiency and evolvability (REST API)**. This two-layer
contract pattern maximizes both developer happiness and technical
agility.

## Conclusion

The dual-layer client contract architecture allows us to reconcile two
often competing goals in service design: **rapid evolution of services**
and **stability for consumers**. By committing to maintain a robust
Python client API for each service, we provide a stable frontier for
development, behind which the service implementation can change as
needed. This pattern has proven beneficial in our projects such as the
MGraph-AI Cache Service and LLM Service, where complex functionality and
strict type requirements demand both flexibility and reliability.

In practice, this approach has yielded a more **resilient and
maintainable system**. Clients are shielded from breaking changes and
enjoy a type-safe, high-level interface. Services can continuously
improve without the dead weight of supporting outdated integration
methods. The use of Type_Safe schemas ensures that both layers speak the
same language and catch mistakes early, embodying the principle that
"**one model serves all layers**" of the application.

Going forward, we will apply this pattern to new services and continue
refining the interplay between the client SDK and service API. With
careful design, clear documentation, and thorough testing, the two-layer
contract approach provides a powerful blueprint for building distributed
systems that are at once **adaptable** and **robust** -- truly the *best
of both worlds* for API design and consumption.

[[1]](https://stackoverflow.com/questions/50400384/in-the-microservices-architecture-why-they-say-is-bad-to-share-rest-client-libr#:~:text=I%20would%20say%20,copy%20and%20pasting%20client%20code)
[[14]](https://stackoverflow.com/questions/50400384/in-the-microservices-architecture-why-they-say-is-bad-to-share-rest-client-libr#:~:text=,along%20with%20virtually%20everyone%20else)
java - In the microservices architecture, why they say is bad to share
REST Client libraries? - Stack Overflow

<https://stackoverflow.com/questions/50400384/in-the-microservices-architecture-why-they-say-is-bad-to-share-rest-client-libr>

[[2]](https://softwareengineering.stackexchange.com/questions/408106/calling-microservice-using-rest-or-dedicated-client-jar#:~:text=helps%20enforce%20the%20REST%20API,as%20the%20actual%20API%20boundary)
api design - Calling Microservice using REST or dedicated client jar -
Software Engineering Stack Exchange

<https://softwareengineering.stackexchange.com/questions/408106/calling-microservice-using-rest-or-dedicated-client-jar>

[[3]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Type_Safe%20is%20a%20runtime%20type,money%2C%20URLs%2C%20and%20file%20paths)
[[5]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=FastAPI%20automatically%3A%201,Handles%20Enum%20serialization%2Fdeserialization)
[[6]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=Benefits%20of%20Type_Safe%20over%20Pydantic,in%20security%2A%2A%20via%20Safe%20primitives)
[[9]](file://file-L82AGA8WRQ1FmWD228jfc6#:~:text=With%20OSBot_Fast_API%27s%20built,FastAPI%20routes%20with%20automatic%20conversion)
v3.1.1__osbot-utils__type-safe__and__python-formatting__guidance.md

<file://file-L82AGA8WRQ1FmWD228jfc6>

[[4]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=def%20store_json%28self%2C%20data%2C%20strategy%3D,json%3Ddata%20%29%20return%20response.json)
[[7]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=Storage%20Operations)
[[8]](file://file-ASwNjb4YTWZfXiLSZbCKpR#:~:text=Retrieval%20Operations)
v0.5.30__cache-service__llm-brief.md

<file://file-ASwNjb4YTWZfXiLSZbCKpR>

[[10]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=,py)
[[11]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=Context%20Manager%20Pattern%20with%20%27_%27)
[[12]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=For%20integration%20tests%2C%20especially%20those,for%20the%20entire%20test%20suite)
[[13]](file://file-WgQy9SUhJpLcPGW6CC5Q9u#:~:text=match%20at%20L1027%20,fast_api__app)
v3.1.1__osbot-utils__type-safe__testing-guidance.md

<file://file-WgQy9SUhJpLcPGW6CC5Q9u>
